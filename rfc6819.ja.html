<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>OAuth 2.0 Threat Model and Security Considerations</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="OAuth 2.0 Threat Model and Security Considerations">
<meta name="keywords" content="authorization, authentication, token, counter-measures, HTTP, REST">
<meta name="generator" content="xml2rfc v1.36 (http://xml.resource.org/)">
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: small; color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: small; font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: small; font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: small; text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>

<table border="0" cellpadding="0" cellspacing="2" width="30" align="right">
    <tr>
        <td class="RFCbug">
                <span class="RFC">&nbsp;RFC&nbsp;</span><br /><span class="hotText">&nbsp;6819&nbsp;</span>
        </td>
    </tr>
    <tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a><br /></td></tr>
</table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Internet Engineering Task Force (IETF)</td><td class="header">T. Lodderstedt, Ed.</td></tr>
<tr><td class="header">Request for Comments: 6819</td><td class="header">Deutsche Telekom AG</td></tr>
<tr><td class="header">Category: Informational</td><td class="header">M. McGloin</td></tr>
<tr><td class="header">ISSN: 2070-1721</td><td class="header">IBM</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">P. Hunt</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Oracle Corporation</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">January 2013</td></tr>
</table></td></tr></table>
<h1><br />OAuth 2.0 Threat Model and Security Considerations</h1>

<h3>Abstract</h3>

<p>
        本ドキュメントでは, OAuth 2.0仕様が定めるSecurity Considerationsの範囲を超え,
        OAuth 2.0プロトコルに関する包括的脅威モデルを基に, さらなるセキュリティ上の検討項目を示す.
      
</p>
<h3>Status of This Memo</h3>
<p>
This document is not an Internet Standards Track specification; it is published for informational purposes.</p>
<p>
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.</p>
<p>
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6819.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2013 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><hr />

<table border="0" cellpadding="0" cellspacing="2" width="30" align="right">
    <tr>
        <td class="RFCbug">
                <span class="RFC">&nbsp;RFC&nbsp;</span><br /><span class="hotText">&nbsp;6819&nbsp;</span>
        </td>
    </tr>
    <tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a><br /></td></tr>
</table>
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
<a href="#anchor2">2.</a>&nbsp;
Overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">2.1.</a>&nbsp;
Scope<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">2.2.</a>&nbsp;
Attack Assumptions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">2.3.</a>&nbsp;
Architectural Assumptions<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">2.3.1.</a>&nbsp;
Authorization Servers<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">2.3.2.</a>&nbsp;
Resource Server<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">2.3.3.</a>&nbsp;
Client<br />
<a href="#sec_features">3.</a>&nbsp;
Security Features<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_tokens">3.1.</a>&nbsp;
Tokens<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">3.1.1.</a>&nbsp;
Scope<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">3.1.2.</a>&nbsp;
Limited Access Token Lifetime<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">3.2.</a>&nbsp;
Access Token<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">3.3.</a>&nbsp;
Refresh Token<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">3.4.</a>&nbsp;
Authorization &quot;code&quot;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">3.5.</a>&nbsp;
Redirect URI<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">3.6.</a>&nbsp;
&quot;state&quot; Parameter<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">3.7.</a>&nbsp;
Client Identifier<br />
<a href="#threat_model">4.</a>&nbsp;
Threat Model<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">4.1.</a>&nbsp;
Clients<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ObtainClientSecrets">4.1.1.</a>&nbsp;
Threat: Obtaining Client Secrets<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">4.1.2.</a>&nbsp;
Threat: Obtaining Refresh Tokens<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">4.1.3.</a>&nbsp;
Threat: Obtaining Access Tokens<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">4.1.4.</a>&nbsp;
Threat: End-User Credentials Phished Using Compromised or Embedded Browser<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#open_redirector_client">4.1.5.</a>&nbsp;
Threat: Open Redirectors on Client<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">4.2.</a>&nbsp;
Authorization Endpoint<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor22">4.2.1.</a>&nbsp;
Threat: Password Phishing by Counterfeit Authorization Server<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor23">4.2.2.</a>&nbsp;
Threat: User Unintentionally Grants Too Much Access Scope<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mal_client3">4.2.3.</a>&nbsp;
Threat: Malicious Client Obtains Existing Authorization by Fraud<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#open_redirector">4.2.4.</a>&nbsp;
Threat: Open Redirector<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor24">4.3.</a>&nbsp;
Token Endpoint<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor25">4.3.1.</a>&nbsp;
Threat: Eavesdropping Access Tokens<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor26">4.3.2.</a>&nbsp;
Threat: Obtaining Access Tokens from Authorization Server Database<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor27">4.3.3.</a>&nbsp;
Threat: Disclosure of Client Credentials during Transmission<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor28">4.3.4.</a>&nbsp;
Threat: Obtaining Client Secret from Authorization Server Database<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor29">4.3.5.</a>&nbsp;
Threat: Obtaining Client Secret by Online Guessing<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor30">4.4.</a>&nbsp;
Obtaining Authorization<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#code_flow">4.4.1.</a>&nbsp;
Authorization &quot;code&quot;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#eavesdropping">4.4.1.1.</a>&nbsp;
Threat: Eavesdropping or Leaking Authorization &quot;codes&quot;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor31">4.4.1.2.</a>&nbsp;
Threat: Obtaining Authorization &quot;codes&quot; from Authorization Server Database<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor32">4.4.1.3.</a>&nbsp;
Threat: Online Guessing of Authorization &quot;code&quot;s<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mal_client">4.4.1.4.</a>&nbsp;
Threat: Malicious Client Obtains Authorization<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor33">4.4.1.5.</a>&nbsp;
Threat: Authorization &quot;code&quot; Phishing<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor34">4.4.1.6.</a>&nbsp;
Threat: User Session Impersonation<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#authz_code_leakage">4.4.1.7.</a>&nbsp;
Threat: Authorization &quot;code&quot; Leakage through Counterfeit Client<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_csrf">4.4.1.8.</a>&nbsp;
Threat: CSRF Attack against redirect-uri<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor35">4.4.1.9.</a>&nbsp;
Threat: Clickjacking Attack against Authorization<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor36">4.4.1.10.</a>&nbsp;
Threat: Resource Owner Impersonation<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor37">4.4.1.11.</a>&nbsp;
Threat: DoS Attacks That Exhaust Resources<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#semi">4.4.1.12.</a>&nbsp;
Threat: DoS Using Manufactured Authorization &quot;codes&quot;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor38">4.4.1.13.</a>&nbsp;
Threat: Code Substitution (OAuth Login)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#implicit_flow">4.4.2.</a>&nbsp;
Implicit Grant<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor39">4.4.2.1.</a>&nbsp;
Threat: Access Token Leak in Transport/Endpoints<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor40">4.4.2.2.</a>&nbsp;
Threat: Access Token Leak in Browser History<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mal_client2">4.4.2.3.</a>&nbsp;
Threat: Malicious Client Obtains Authorization<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor41">4.4.2.4.</a>&nbsp;
Threat: Manipulation of Scripts<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor42">4.4.2.5.</a>&nbsp;
Threat: CSRF Attack against redirect-uri<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor43">4.4.2.6.</a>&nbsp;
Threat: Token Substitution (OAuth Login)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#pwd_flow">4.4.3.</a>&nbsp;
Resource Owner Password Credentials<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor44">4.4.3.1.</a>&nbsp;
Threat: Accidental Exposure of Passwords at Client Site<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor45">4.4.3.2.</a>&nbsp;
Threat: Client Obtains Scopes without End-User Authorization<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor46">4.4.3.3.</a>&nbsp;
Threat: Client Obtains Refresh Token through Automatic Authorization<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor47">4.4.3.4.</a>&nbsp;
Threat: Obtaining User Passwords on Transport<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor48">4.4.3.5.</a>&nbsp;
Threat: Obtaining User Passwords from Authorization Server Database<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor49">4.4.3.6.</a>&nbsp;
Threat: Online Guessing<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor50">4.4.4.</a>&nbsp;
Client Credentials<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor51">4.5.</a>&nbsp;
Refreshing an Access Token<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor52">4.5.1.</a>&nbsp;
Threat: Eavesdropping Refresh Tokens from Authorization Server<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor53">4.5.2.</a>&nbsp;
Threat: Obtaining Refresh Token from Authorization Server Database<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor54">4.5.3.</a>&nbsp;
Threat: Obtaining Refresh Token by Online Guessing<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor55">4.5.4.</a>&nbsp;
Threat: Refresh Token Phishing by Counterfeit Authorization Server<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor56">4.6.</a>&nbsp;
Accessing Protected Resources<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor57">4.6.1.</a>&nbsp;
Threat: Eavesdropping Access Tokens on Transport<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor58">4.6.2.</a>&nbsp;
Threat: Replay of Authorized Resource Server Requests<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor59">4.6.3.</a>&nbsp;
Threat: Guessing Access Tokens<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor60">4.6.4.</a>&nbsp;
Threat: Access Token Phishing by Counterfeit Resource Server<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor61">4.6.5.</a>&nbsp;
Threat: Abuse of Token by Legitimate Resource Server or Client<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor62">4.6.6.</a>&nbsp;
Threat: Leak of Confidential Data in HTTP Proxies<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor63">4.6.7.</a>&nbsp;
Threat: Token Leakage via Log Files and HTTP Referrers<br />
<a href="#security_considerations">5.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor64">5.1.</a>&nbsp;
General<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#conf_requests">5.1.1.</a>&nbsp;
Ensure Confidentiality of Requests<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#server_authn">5.1.2.</a>&nbsp;
Utilize Server Authentication<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#informed">5.1.3.</a>&nbsp;
Always Keep the Resource Owner Informed<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor65">5.1.4.</a>&nbsp;
Credentials<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cred_storage_prot">5.1.4.1.</a>&nbsp;
Enforce Credential Storage Protection Best Practices<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#online_secrets">5.1.4.2.</a>&nbsp;
Online Attacks on Secrets<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor68">5.1.5.</a>&nbsp;
Tokens (Access, Refresh, Code)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#limit_scope">5.1.5.1.</a>&nbsp;
Limit Token Scope<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#exp_time">5.1.5.2.</a>&nbsp;
Determine Expiration Time<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#short_exp_time">5.1.5.3.</a>&nbsp;
Use Short Expiration Time<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#one_time_usage">5.1.5.4.</a>&nbsp;
Limit Number of Usages or One-Time Usage<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#bind_token_rs">5.1.5.5.</a>&nbsp;
Bind Tokens to a Particular Resource Server (Audience)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#endpoint_audience">5.1.5.6.</a>&nbsp;
Use Endpoint Address as Token Audience<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#audience_token_scope">5.1.5.7.</a>&nbsp;
Use Explicitly Defined Scopes for Audience and Tokens<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#bind_token_client_id">5.1.5.8.</a>&nbsp;
Bind Token to Client id<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#signed_tokens">5.1.5.9.</a>&nbsp;
Sign Self-Contained Tokens<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#enc_token">5.1.5.10.</a>&nbsp;
Encrypt Token Content<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#assertion_format">5.1.5.11.</a>&nbsp;
Adopt a Standard Assertion Format<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#access_tokens">5.1.6.</a>&nbsp;
Access Tokens<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor69">5.2.</a>&nbsp;
Authorization Server<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor70">5.2.1.</a>&nbsp;
Authorization &quot;codes&quot;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#automatic_code_revocation">5.2.1.1.</a>&nbsp;
Automatic Revocation of Derived Tokens If Abuse Is Detected<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#refresh_tokens">5.2.2.</a>&nbsp;
Refresh Tokens<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#restricted_refresh">5.2.2.1.</a>&nbsp;
Restricted Issuance of Refresh Tokens<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#binding_refresh_client_id">5.2.2.2.</a>&nbsp;
Binding of Refresh Token to &quot;client_id&quot;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#refresh_replace">5.2.2.3.</a>&nbsp;
Refresh Token Rotation<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#refresh_revocation">5.2.2.4.</a>&nbsp;
Revocation of Refresh Tokens<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#device_id">5.2.2.5.</a>&nbsp;
Device Identification<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#clickjacking_xframe">5.2.2.6.</a>&nbsp;
X-FRAME-OPTIONS Header<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#client_aa">5.2.3.</a>&nbsp;
Client Authentication and Authorization<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#dont_issue">5.2.3.1.</a>&nbsp;
Don't Issue Secrets to Clients with Inappropriate Security Policy<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#forced_user_consent">5.2.3.2.</a>&nbsp;
Require User Consent for Public Clients without Secret<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#client_id_redirect">5.2.3.3.</a>&nbsp;
Issue a &quot;client_id&quot; Only in Combination with &quot;redirect_uri&quot;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#depl_specific_secretes">5.2.3.4.</a>&nbsp;
Issue Installation-Specific Client Secrets<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#val_redirect">5.2.3.5.</a>&nbsp;
Validate Pre-Registered &quot;redirect_uri&quot;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#client_secret_revocation">5.2.3.6.</a>&nbsp;
Revoke Client Secrets<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#strong_client_authn">5.2.3.7.</a>&nbsp;
Use Strong Client Authentication (e.g., client_assertion/client_token)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor71">5.2.4.</a>&nbsp;
End-User Authorization<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#automatic_processing">5.2.4.1.</a>&nbsp;
Automatic Processing of Repeated Authorizations Requires Client Validation<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#informed_decisions">5.2.4.2.</a>&nbsp;
Informed Decisions Based on Transparency<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#validation_end_user">5.2.4.3.</a>&nbsp;
Validation of Client Properties by End User<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#bind_code_client_id">5.2.4.4.</a>&nbsp;
Binding of Authorization &quot;code&quot; to &quot;client_id&quot;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#bind_code_redirect">5.2.4.5.</a>&nbsp;
Binding of Authorization &quot;code&quot; to &quot;redirect_uri&quot;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor72">5.3.</a>&nbsp;
Client App Security<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cred_software">5.3.1.</a>&nbsp;
Don't Store Credentials in Code or Resources Bundled with Software Packages<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#std_web">5.3.2.</a>&nbsp;
Use Standard Web Server Protection Measures (for Config Files and Databases)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#secure_storage">5.3.3.</a>&nbsp;
Store Secrets in Secure Storage<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#device_lock">5.3.4.</a>&nbsp;
Utilize Device Lock to Prevent Unauthorized Device Access<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#link_state_uasession">5.3.5.</a>&nbsp;
Link the &quot;state&quot; Parameter to User Agent Session<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor73">5.4.</a>&nbsp;
Resource Servers<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#authz_header">5.4.1.</a>&nbsp;
Authorization Headers<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#authn_requests">5.4.2.</a>&nbsp;
Authenticated Requests<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#signed_requests">5.4.3.</a>&nbsp;
Signed Requests<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#installed_apps">5.5.</a>&nbsp;
A Word on User Interaction and User-Installed Apps<br />
<a href="#Acknowledgements">6.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.references1">7.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">7.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">7.2.</a>&nbsp;
Informative References<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>
        本ドキュメントでは, OAuth仕様が定めるSecurity Considerationsの範囲を超え,
        OAuth 2.0プロトコル <a class='info' href='#RFC6749'>[RFC6749]<span> (</span><span class='info'>Hardt, D., &ldquo;The OAuth 2.0 Authorization Framework,&rdquo; October&nbsp;2012.</span><span>)</span></a> に関する包括的脅威モデルを基に, さらなるセキュリティ上の検討項目を示す.
        本ドキュメントは以下の項目について扱う.
        </p>
<ul class="text">
<li>
            脅威モデル策定の前提となる仮説およびその影響範囲を定める.
          
</li>
<li>
            OAuthプロトコルのセキュリティ上の特徴について述べ, それらが攻撃阻止のためにどのような役割を持つかをまとめる.
          
</li>
<li>
            OAuthの包括的脅威モデル, およびそれらへの対抗策についてまとめる.
          
</li>
</ul><p>
        ここで述べる脅威には, OAuthトークンやそれによって保護されるリソースに対する意図的な攻撃の他, 適切なセキュリティ対策が施されていない場合に起こりうるセキュリティリスクも含む.
        各脅威はプロトコル仕様の構造に基づいて整理され, デベロッパーが実装時に参照しやすく考慮されている.
        例えば, アクセスを許可する際の脅威や各grant typeそれぞれに固有の脅威, リソースサーバーに関わる脅威などが, 該当する章・節にまとめて紹介されている.
      
</p>
<p>
        注)
        本ドキュメントはそれぞれの脅威の発生確率や具体的なリスクについては述べない.
        そういった項目は, 実装やサービス内容に大きく左右されるためである.
        本ドキュメントは抽象的なレベルでの議論を行うが, ここで述べられる情報は実装固有の脅威モデルを考慮する際の基礎となるであろう.
        実装者には, 抽象的な脅威モデルを実際の実装にあてはめ, リスク分析を行うことが求められる.
        なお本ドキュメントはOAuth 2.0仕様本体を対象としており, 本ドキュメント執筆現在仕様策定が進んでいるクライアント登録やディスカバリーなどの拡張仕様については考慮しない.
      
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Overview</h3>

<p>
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Scope</h3>

<p>
          本ドキュメントで述べられるSecurity Considerationsは, <a class='info' href='#RFC6749'>[RFC6749]<span> (</span><span class='info'>Hardt, D., &ldquo;The OAuth 2.0 Authorization Framework,&rdquo; October&nbsp;2012.</span><span>)</span></a> がサポートする, 特定のOAuthサーバーと紐づくクライアントのみを考慮する.
          こういった実装は以下のような特徴を持つ.
        
</p>
<p>
          </p>
<ul class="text">
<li>
              リソースサーバーURLは固定で実装時に既に周知されている.
              認可サーバーURLは固定もしくは事前に知ることができる.
            
</li>
<li>
              トークンのscopeに指定される値 (アプリケーションURLやmethodなど) は, 実装時に周知されている.
            
</li>
<li>
              クライアント登録は現在のCore仕様の範囲外である.
              従って本ドキュメントはstatic/dynamicに関わらず幅広いクライアント登録方法を想定する.
            
</li>
</ul><p>
          また以下の項目は対象外とする.
        
</p>
<p>
          </p>
<ul class="text">
<li>
              認可サーバー・リソースサーバー間のコミュニケーション.
            
</li>
<li>
              トークンフォーマット.
            
</li>
<li>
              認可サーバーがユーザーを認証する方式.
              ただしリソースオーナーパスワードクレデンシャルグラント (<a class='info' href='#RFC6749'>[RFC6749]<span> (</span><span class='info'>Hardt, D., &ldquo;The OAuth 2.0 Authorization Framework,&rdquo; October&nbsp;2012.</span><span>)</span></a> Section 4.3 参照) については対象とする.
            
</li>
<li>
              アサーション取得メカニズムおよび不正なアサーションによってもたらされる攻撃.
            
</li>
<li>
              特定のOAuthサーバーと紐づけられていないクライアント.
              例えばPortable Contacts API <a class='info' href='#Portable-Contacts'>[Portable&#8209;Contacts]<span> (</span><span class='info'>Smarr, J., &ldquo;Portable Contacts 1.0 Draft C,&rdquo; August&nbsp;2008.</span><span>)</span></a> 経由でコンタクトリストにアクセスすることができるメールクライアントなど.
              このようなクライアントは事前に特定のOAuthサーバーと紐づけておくことはできず, dynamicにOAuthプロトコルの各URLを検知 (discover) する必要がある.
            
</li>
</ul><p>
        
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
Attack Assumptions</h3>

<p>
          アタッカーとリソースに関して, 以下の想定を置く.
        
</p>
<p>
          </p>
<ul class="text">
<li>
              アタッカーはクライアントと認可サーバー, およびクライアントとリソースサーバーの間のネットワークに直接アクセス可能であり, そこでのいかなる通信も盗聴できる状態にある.
              ただし認可サーバー・リソースサーバー間の通信へはアクセスできないものとする.
            
</li>
<li>
              アタッカーが攻撃に利用するリソースに制限は無い物とする.
            
</li>
<li>
              OAuthプロトコルに関与する3者のうちの2者が, 共謀して残る1者に対する攻撃を行う可能性があるものとする.
              例えば, クライアントと認可サーバーがアタッカーの管理下にあり, リソースアクセスを得るためユーザーを騙すため共謀するケースなどが考えられる.
            
</li>
</ul><p>
        
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3"></a><h3>2.3.&nbsp;
Architectural Assumptions</h3>

<p>
          本セクションではセキュリティ上重要なデータに関して, OAuthの各エンティティが持ちうる機能, 制限および設計上のオプションについて仮定する.
          これらは脅威解析における基礎となる.
        
</p>
<p>
          OAuthプロトコルはある程度実装に自由度を残している.
          Core仕様は認可サーバーとリソースサーバーの基本的なコンセプトを定めている.
          これら両サーバーは単一のエンティティとして実装されることもあれば, 分散した複数のエンティティとして実装される場合もある.
          後者の典型例としては, 複数のサービスを提供している事業者が, 単一の認証・認可サービスを, 特にミドルウェアレベルで共通に用いるケースなどがある.
        
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3.1"></a><h3>2.3.1.&nbsp;
Authorization Servers</h3>

<p>
            認可サーバーでは, 以下のデータが保存されているかアクセス可能な状態にある.
          
</p>
<p>
            </p>
<ul class="text">
<li>
                ユーザーネームとパスワード
              
</li>
<li>
                クライアントIDとクライアントシークレット
              
</li>
<li>
                特定のクライアントと紐づけられたリフレッシュトークン
              
</li>
<li>
                特定のクライアントと紐づけられたアクセストークン
                (Handleベースデザイン <a class='info' href='#section_tokens'>Section&nbsp;3.1<span> (</span><span class='info'>Tokens</span><span>)</span></a> を用いる場合)
              
</li>
<li>
                HTTPS 証明書/鍵
              
</li>
<li>
                認可プロセスごとの "redirect_uri", "client_id" および認可コード "code"
                (Handleベースデザイン <a class='info' href='#section_tokens'>Section&nbsp;3.1<span> (</span><span class='info'>Tokens</span><span>)</span></a> を用いる場合)
              
</li>
</ul><p>
            (訳注: Assertionタイプのトークンを用いる場合, redirect_uri や client_id などがトークン自体に含まれており, それらが認可サーバー上には保存されていない場合もある)
          
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3.2"></a><h3>2.3.2.&nbsp;
Resource Server</h3>

<p>
            リソースサーバーでは, 以下のデータが保存されているかアクセス可能な状態にある.
          
</p>
<p>
            </p>
<ul class="text">
<li>
                ユーザーデータ (詳細はプロトコルの範囲外)
              
</li>
<li>
                HTTPS 証明書/鍵
              
</li>
<li>
                認可サーバークレデンシャルもしくは認可サーバー共有鍵/公開鍵
                (前者はHandleベースデザイン <a class='info' href='#section_tokens'>Section&nbsp;3.1<span> (</span><span class='info'>Tokens</span><span>)</span></a> を用いる場合, 後者はAssertionベースデザイン <a class='info' href='#section_tokens'>Section&nbsp;3.1<span> (</span><span class='info'>Tokens</span><span>)</span></a> を用いる場合)
              
</li>
<li>
                (リクエストごとの) アクセストークン
              
</li>
</ul><p>
            リソースサーバーはリフレッシュトークン, ユーザーパスワードおよびクライアントシークレットは知らないものとする.
          
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3.3"></a><h3>2.3.3.&nbsp;
Client</h3>

<p>
            OAuthでは, クライアントとはリソースオーナーの代理として, リソースオーナーの認可のもとで保護リソースへのアクセスを行うアプリケーションである.
            Webアプリケーション, ユーザーエージェントベースアプリケーション, ネイティブアプリケーションといったクライアントタイプごとに, 実装上およびセキュリティ上の特徴は異なる.
            クライアントタイプとそのプロフィールについては <a class='info' href='#RFC6749'>[RFC6749]<span> (</span><span class='info'>Hardt, D., &ldquo;The OAuth 2.0 Authorization Framework,&rdquo; October&nbsp;2012.</span><span>)</span></a> Section 2.1 に定義されている.
          
</p>
<p>
            クライアントでは, 以下のデータが保存されているかアクセス可能な状態にある.
          
</p>
<p>
            </p>
<ul class="text">
<li>
                クライアントID (およびクライアントシークレットもしくはそれに相当する何らかのクライアントクレデンシャル)
              
</li>
<li>
                エンドユーザーごと, もしくはその他のセキュリティコンテキストや委譲コンテキストごとの, 1つ以上のリフレッシュトークン (長期間) およびアクセストークン (短期間)
              
</li>
<li>
                信頼された証明機関の証明書 (Trusted CA certificates, HTTPS)
              
</li>
<li>
                認可プロセスごとの "redirect_uri", 認可コード "code"
              
</li>
</ul><p>
          
</p>
<a name="sec_features"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Security Features</h3>

<p>
        OAuth 2.0には, ある程度プロトコルレベルで攻撃やセキュリティリスクに対する対策が施されている.
      
</p>
<a name="section_tokens"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Tokens</h3>

<p>
          OAuthは広範囲に渡っていろいろな種類のトークン (アクセストークン, リフレッシュトークン, 認可コード) を用いる.
          トークンの表現方法としては以下の2通りがある.
        
</p>
<p>
          </p>
<blockquote class="text"><dl>
<dt>Handle (or artifact)</dt>
<dd>
              "handle" ("artifact" とも呼ばれる) とは, 認可サーバー内部のデータ構造に対するある種の参照である.
              内部データ構造には, ユーザーID (UID) やスコープなどのトークンの属性が含まれる.
              handleを用いることで, トークン無効化処理を簡略化し, 暗号化メカニズムを不要にすることができる.
              一方でhandleを用いると, 検証およびトークン内容取得のために, 発行者と消費者 (認可サーバーとリソースサーバーなど) の間の通信が必須となる.
              これはトークンの発行者と利用者 (認可サーバーとリソースサーバーなど) が異なるエンティティである場合, パフォーマンスやスケーラビリティの点で不利である.
              したがってhandleは主に発行者と消費者 (認可サーバーとリソースサーバーなど) が同一エンティティである場合に用いられることになるであろう.
              handleトークンはしばしば "opaque" トークンと呼ばれるが, これはリソースサーバーがそのトークン自体を解読する必要がなく, 単なるトークン文字列として利用するのみだからである.
            
</dd>
<dt>Assertion (aka self-contained token)</dt>
<dd>
              assertionとはパース可能なトークンである.
              assertionは典型的には有効期間, 発行対象 (audience) を持ち, 改竄防止および発行者認証のため電子署名が付けられる.
              SAML assertion <a class='info' href='#OASIS.saml-core-2.0-os'>[OASIS.saml&#8209;core&#8209;2.0&#8209;os]<span> (</span><span class='info'>Cantor, S., Ed., Kemp, J., Ed., Philpott, R., Ed., and E. Maler, Ed., &ldquo;Assertions and Protocols for the OASIS Security Assertion Markup Language (SAML) V2.0,&rdquo; March&nbsp;2005.</span><span>)</span></a> や Kerberos ticket <a class='info' href='#RFC4120'>[RFC4120]<span> (</span><span class='info'>Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;The Kerberos Network Authentication Service (V5),&rdquo; July&nbsp;2005.</span><span>)</span></a> が例として挙げられる.
              assertionは典型的にはリソースサーバーに直接検証される.
              このときリソースサーバーと認可サーバーの間で通信を行う必要はない.
              これはトークンの発行者と利用者 (認可サーバーとリソースサーバーなど) が異なるエンティティである場合, パフォーマンスやスケーラビリティの点で有利である.
              ただしassertionを用いた場合, トークン無効化の実装はhandleを用いた場合より困難である.
            
</dd>
</dl></blockquote><p>
          リソースサーバーへのリクエストにトークンを利用する場合, 以下の2つの方法を取りうる.
        
</p>
<p>
          </p>
<blockquote class="text"><dl>
<dt>bearer token</dt>
<dd>
              bearer tokenとは, それを受け取ったいかなるクライアントにも利用可能なトークンである (<a class='info' href='#RFC6750'>[RFC6750]<span> (</span><span class='info'>Jones, M. and D. Hardt, &ldquo;The OAuth 2.0 Authorization Framework: Bearer Token Usage,&rdquo; October&nbsp;2012.</span><span>)</span></a>).
              トークンを所有していることのみがその利用条件であるため, エンドポイント間での通信がセキュアに保たれ, 許可されたエンドポイントのみがそのトークンにアクセスできる状態を担保することが重要である.
              bearer tokenは, クライアントアプリケーションにとっては (proof tokenのように) 利用に際して特別な処理を行う必要がないため便利である.
              bearer tokenはWeb上で single-sign-on (SSO) を行う際ブラウザで用いられるcookieと類似の特徴を持つ.
            
</dd>
<dt>proof token</dt>
<dd>
              proof tokenは特定のクライアントにのみ利用可能なトークンである.
              クライアントは, トークン利用に際して毎回自身がトークン利用可能な主体であることを証明するために何らかの処理を行う必要がある.
              クライアントにリクエスト内容に対して特定のトークンと紐づいた秘密鍵を用いて電子署名を要求する, MACタイプのアクセストークン (<a class='info' href='#OAuth-HTTP-MAC'>[OAuth&#8209;HTTP&#8209;MAC]<span> (</span><span class='info'>Richer, J., Ed., Mills, W., Ed., and H. Tschofenig, Ed., &ldquo;OAuth 2.0 Message Authentication Code (MAC) Tokens,&rdquo; November&nbsp;2012.</span><span>)</span></a>) などがその例である.
            
</dd>
</dl></blockquote><p>
        
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.1"></a><h3>3.1.1.&nbsp;
Scope</h3>

<p>
            scopeは, 特定のトークンに紐づき, リソースサーバー, リソース, およびリソースへの操作に関するアクセス認可を示す.
            scopeは, OAuthにおいてアクセストークンの持つ権限を明示的に示す手段となる.
            scopeは, 認可サーバーとエンドユーザーが, 比較的セキュアでなく信頼度の低いと考えられるOAuthクライアントに対して, リソースへのアクセス権限を制限・制御するために用いられる.
            クライアントは必要に応じてトークンの権限を狭めるためだけにscopeを用いることができる.
            (例: セキュアでないチャネルを通じてトークンが送信される際, 潜在的リスクを軽減するためなど)
            典型的には, scopeはトークンの有効期間 (lifetime) 制限と併用され, 補完関係にある.
          
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.2"></a><h3>3.1.2.&nbsp;
Limited Access Token Lifetime</h3>

<p>
            "expires_in" というプロトコルパラメーターによって, 認可サーバーはアクセストークンの有効期間 (lifetime) を制限し, そのlifetimeに関する情報をクライアントに通知することができる.
            (lifetimeは, ユーザーの意思によって行われたり, 認可サーバーのポリシーによって決定される)
            このメカニズムにより, 認可サーバーが比較的セキュアでないと見なすOAuthクライアントに対して有効期間の短いトークンを発行したり, セキュアでないチャネルを利用する際に同様に有効期間を短くしたりすることができる.
          
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Access Token</h3>

<p>
          アクセストークンはクライアントがリソースにアクセスする際に用いられる.
          アクセストークンには, 典型的には (数分〜数時間程度の) セッションのlifetimeをカバーする程度の短い有効期間が設定される.
          アクセストークンはリフレッシュトークンを用いることでリフレッシュ可能である.
          有効期間の短いアクセストークンとリフレッシュトークンを併用することで, 明示的な無効化処理無しにアクセストークンの無効化が行われる可能性を高めることができる.
        
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Refresh Token</h3>

<p>
          リフレッシュトークンは, 特定のクライアントに対する長期間有効な認可情報を示す.
          このトークンはクライアント・認可サーバー間でのみ送信される.
          クライアントはこのトークンを使って新しい ("refresh" された) アクセストークンを取得することができる.
        
</p>
<p>
          リフレッシュトークンによって, アクセストークンの有効期間を短く保ちつつ, ユーザーの関与無しに長期間有効なアクセス権限を維持することができる.
          リフレッシュトークンは, (分散環境など) リソースサーバーと認可サーバーが同一エンティティでない場合に1つのアドバンテージをもたらす.
          認可サーバーがリフレッシュトークンを無効化するだけで, 発行済アクセストークンが期限切れになった時点ですべてのアクセス権限を無効化することができるのである.
          この際, アクセストークンの有効期間を短く保つことは, タイムリーなアクセス権限無効化の為に重要なポイントとなる.
          (訳注: アクセストークンが複数のリソースサーバーに分散してしまっている状況で, それを確実に無効化するのは面倒な処理である)
        
</p>
<p>
          リフレッシュトークンは, クライアント識別子および認可リクエストを行った特定のクライアントインスタンスに紐づいたsecretでもあり, リソースオーナー認可そのものを示すものでもある.
          このことは以下の認可プロセスによって保証される.
        
</p>
<p>
          </p>
<ol class="text">
<li>
              リソースオーナーとユーザーエージェントがセキュアに認可コードをクライアントインスタンスに送付する.
            
</li>
<li>
              クライアントは即座にセキュアチャネルを通じてそれを認可サーバーに送り, 受け取ったリフレッシュトークンをセキュアに保存する.
            
</li>
<li>
              クライアントは常にリフレッシュトークンをセキュアチャネルを通じて送信し, アクセストークンを取得する.
              (この際オプションで新たなリフレッシュトークンを得る)
            
</li>
</ol><p>
          以上により, クライアントが特定のトークンの秘匿性を維持する限り, リフレッシュトークンはクライアント自身を認証するためにも用いることができる.
        
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;
Authorization &quot;code&quot;</h3>

<p>
          認可コード ("code") はエンドユーザー認可の取得に成功した結果として発行され, クライアントがアクセストークンおよびリフレッシュトークンを取得する際の中間物として動作する.
          認可コードは以下の2つの目的で, トークンの代わりにクライアントのリダイレクトURIに送信される.
        
</p>
<p>
          </p>
<ol class="text">
<li>
              ブラウザベースフローでは, プロトコルパラメーターは潜在的アタッカーにアクセス可能な状態になる.
              ブラウザキャッシュやログファイルなどがその経路となりうる.
              またアタッカーによって異なる値に置き換えられる可能性もある.
              これらのリスクを軽減するため, トークンの代わりに有効期間の短い認可コードを送信し, それをよりセキュアなクライアント・認可サーバー間のダイレクト通信を通じてトークンと交換するのである.
            
</li>
<li>
              クライアント認証は, ダイレクト通信ではない認可リクエストより, ダイレクト通信によって行う方が遥かに簡単である.
              認可リクエスト時にクライアント認証を行うには, 電子署名が必要となる.
            
</li>
</ol><p>
        
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5"></a><h3>3.5.&nbsp;
Redirect URI</h3>

<p>
          リダイレクトURIを用いることで, 不正クライアントの検知やフィッシング攻撃の防止に役立つ.
          実際に認可リクエスト時に用いられたリダイレクトURIは, 認可コードをトークンと交換する際に提示され検証される.
          これにより認可コードがリダイレクタを通じて偽のクライアントに漏洩した際にも, 攻撃を防ぐことができる.
          認可サーバーはパブリッククライアントおよびimplicitグラントタイプを利用するコンフィデンシャルクライアントに対しては, リダイレクトURIの事前登録を必須とし, 認可リクエスト時に指定されるリダイレクトURIを事前登録済みのそれと比較検証するべきである.
        
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.6"></a><h3>3.6.&nbsp;
&quot;state&quot; Parameter</h3>

<p>
          stateパラメーターは, リクエストとそれに対するコールバックを紐づけCSRF攻撃 (<a class='info' href='#section_csrf'>Section&nbsp;4.4.1.8<span> (</span><span class='info'>Threat: CSRF Attack against redirect-uri</span><span>)</span></a>) を防止するために用いられる.
          CSRF攻撃においては, アタッカーは自身のリソースへのアクセスを許可し, アタッカーに対して発行されたトークンを含むリダイレクトリクエストをユーザーに実行させる.
          stateパラメーターはユーザーエージェントと紐付けられ, ユーザーエージェントはそれをクライアントおよびユーザーエージェントのみにアクセス可能な場所に保存する.
          (例: same-originポリシーによって保護された場所)
        
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.7"></a><h3>3.7.&nbsp;
Client Identifier</h3>

<p>
          認証プロトコルは一般的にエンドユーザーの代理として動作するソフトウェアコンポーネントの素性に関しては考慮しない.
          しかしながらOAuthはそれを考慮し, 認可委譲におけるセキュリティレベルを向上している.
          OAuthクライアントがユーザーが不在な状況でも動作しうるとうことも, その理由である.
        
</p>
<p>
          OAuthでは以下のように, 一連のリクエストが同一クライアントによって実行されているかを照合するため, クライアント識別子を用いる.
        
</p>
<p>
          </p>
<ul class="text">
<li>
              特定エンドユーザーの認可プロセスと, それに続くトークンエンドポイントにおける認可コードとトークンの交換リクエスト
            
</li>
<li>
              エンドユーザーによる特定クライアントへの認可およびその際に発行された初期のトークンと, 該当クライアントがその後ユーザーの同意無しに取得したトークン
              (初回以降の認可自動承認プロセスを意味する)
            
</li>
</ul><p>
          クライアント識別子は, 認可サーバーがユーザーに同意を求める際に, そのクライアントに関する情報を表示するためにも用いられる.
          さらに特定のクライアントからのリクエスト数を制限したり, リクエストに対して課金を行う際に用いられることもある.
          サーバーログファイルなどで異なるクライアントからのアクセスを区別する際に用いることもできるであろう.
        
</p>
<p>
          OAuthは, クライアントが認可サーバーに対して自身を認証する能力に基づいて, コンフィデンシャルとパブリックという2つのクライアントタイプを定義している.
          (例: クライアントクレデンシャルの秘匿性を保持できるかどうかなど)
          コンフィデンシャルクライアントはクライアントクレデンシャル (クライアント識別子と紐づいたクライアントシークレットなど) を秘匿に保つことができる, もしくはクライアントアサーション (SAML参照) や鍵暗号法などの手段によりセキュアにクライアント認証を行うことができる.
          なお後者のクライアントアサーション (SAML参照) や鍵暗号法を用いた手段の方が, よりセキュアであると考えられる.
        
</p>
<p>
          認可サーバーはクライアントがシークレットを秘匿に保てるかどうか, セキュアな認証方式を利用可能かどうかなどを特定すべきである.
          ただしその代わりにエンドユーザーがクライアントの素性を検証することも可能である.
          (信頼できるアプリケーションのみをインストールするなど)
          リダイレクトURIは, クレデンシャルを偽のクライアントに送信することを防止するために用いられる場合もあるが, クライアントの素性を検証するために用いることはできない.
        
</p>
<p>
          クライアントはクライアントタイプ, プロフィールおよびデプロイモデルによって以下のように分類できる.
          (native, webアプリケーションなど, <a class='info' href='#RFC6749'>[RFC6749]<span> (</span><span class='info'>Hardt, D., &ldquo;The OAuth 2.0 Authorization Framework,&rdquo; October&nbsp;2012.</span><span>)</span></a> Section 9参照)
        
</p>
<p>
          </p>
<blockquote class="text"><dl>
<dt>Deployment-independent &quot;client_id&quot; with pre-registered &quot;redirect_uri&quot; and without &quot;client_secret&quot;</dt>
<dd>
              このケースでは, クライアント識別子は同一ソフトウェアの複数インスタンスに共通して利用される.
              このようなクライアント識別子はエンドユーザーの関与無しには検証できない.
              ネイティブアプリケーションにおいては, ユーザーにクライアントのメタ情報を提示し, ログファイル中でクライアントを区別するには十分である.
              このクライアント識別子に紐づくアクセス権限の無効化は, 同一ソフトウェアの全インスタンスに影響する.
            
</dd>
<dt>Deployment-independent &quot;client_id&quot; with pre-registered &quot;redirect_uri&quot; and with &quot;client_secret&quot;</dt>
<dd>
              これはネイティブアプリケーションのためだけのオプションである.
              この分類は, クライアントシークレットが適切に保護されないため推奨されない. (<a class='info' href='#ObtainClientSecrets'>Section&nbsp;4.1.1<span> (</span><span class='info'>Threat: Obtaining Client Secrets</span><span>)</span></a> 参照)
              セキュリティ上の弱点のため, このようなクライアント識別子は上記のシークレットを持たないクライアントと同レベルの信頼度となる.
              アクセス権減の無効化は, 同一ソフトウェアの全インスタンスに影響する.
            
</dd>
<dt>Deployment-specific &quot;client_id&quot; with pre-registered &quot;redirect_uri&quot; and with &quot;client_secret&quot;</dt>
<dd>
              クライアント登録プロセスにおいて, リダイレクトURI, WebサイトURL, Webサイト名および連絡先などのクライアント属性の検証が行われることが保証される.
              このようなクライアントは上記のすべてのユースケースで利用可能である.
              このレベルは手動もしくはユーザーごとに固有の登録プロセスを伴うWebアプリケーションで実現される.
              ネイティブアプリケーションでこのレベルを実現するのは非常に困難である.
              ただし, アプリケーションのインストールが管理者によって行われ, 管理者によってクライアントの真正性が検証されているか, (アプリケーションマーケットプロバイダなどにより) end-to-endで単一エンティティによってデバイスインストールごとにクライアントクレデンシャルの生成が行われている場合には, ネイティブアプリケーションでもこのレベルを実現することは可能である.
              アクセス権限の無効化は, 単一のインスタンスにのみ影響する.
            
</dd>
<dt>Deployment-specific &quot;client_id&quot; with &quot;client_secret&quot; without validated properties</dt>
<dd>
              このようなクライアントは認可サーバーによって特定トランザクション内のリクエスト (認可リクエスト, トークン発行リクエスト, リフレッシュトークン発行リクエストおよびアクセストークンリフレッシュリクエストなど) でのみ識別される.
              認可サーバーはいかなるクライアント属性をもエンドユーザーに保証することはできない.
              再認可時の自動認可処理は可能である.
              このようなクライアントクレデンシャルはクライアント属性の検証無しに自動的に生成可能である.
              これは特にネイティブアプリケーションには新たな選択肢となりうるであろう.
              アクセス権限の無効化は, 単一のインスタンスにのみ影響する.
            
</dd>
</dl></blockquote><p>
        
</p>
<a name="threat_model"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Threat Model</h3>

<p>
        このセクションではOAuth 2.0の脅威モデルを網羅的にまとめる.
        まず各脅威を, クライアント, 認可サーバーおよびリソースサーバーという, 攻撃対象となる各OAuthコンポーネントごとに分類する.
        続いてトークン取得と保護リソースへのアクセスという, フロー単位での分類を行う.
        それぞれに対する対抗策は <a class='info' href='#security_considerations'>Section&nbsp;5<span> (</span><span class='info'>Security Considerations</span><span>)</span></a> にまとめる.
      
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Clients</h3>

<p>
          このセクションではOAuthクライアントに対する脅威について述べる.
        
</p>
<a name="ObtainClientSecrets"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.1"></a><h3>4.1.1.&nbsp;
Threat: Obtaining Client Secrets</h3>

<p>
            アタッカーは以下のようにして, 特定のクライアントのシークレットにアクセスする可能性がある.
            (訳注: ここでの "access" は, secretが持つ権限に対するアクセスを意味し, あたかもそれを知っているかのようにして振る舞える, というニュアンス)
          
</p>
<p>
            </p>
<ul class="text">
<li>
                リフレッシュトークンおよび認可コードに対するリプレイ攻撃を行なう.
              
</li>
<li>
                攻撃対象となるクライアントのclient_idを用いて該当クライアントになりすまし, トークンを取得する.
              
</li>
</ul><p>
            このような攻撃により, 以下のような影響が発生しうる.
          
</p>
<p>
            </p>
<ul class="text">
<li>
                認可サーバーアクセス時のクライアント認証をバイパスされる.
              
</li>
<li>
                漏洩したリフレッシュトークンまたは認可コードを利用される.
              
</li>
</ul><p>
            クライアントの種類によっては, 以下のような攻撃も考えられる.
          
</p>
<p>
            攻撃例: ソースコードまたはバイナリーからシークレットを取得
          
</p>
<p>
            これはどのようなクライアントに対しても起こりうる攻撃である.
            オープンソースプロジェクトでは, 公開レポジトリにあるソースコードから直接シークレットが漏洩する可能性がある.
            アタッカーにソースコードが渡らない状況でも, バイナリーからシークレットを取得することもできる.
            アプリケーション配布時にいかにシークレットの難読化を行っても, リバースエンジニアリングによってシークレットが漏洩する可能性は考慮すべきである.
          
</p>
<p>
            対抗策
          
</p>
<p>
            </p>
<ul class="text">
<li>
                パブリッククライアントやセキュリティポリシーを満たさないクライアントに対してシークレットを発行しない.
                (<a class='info' href='#dont_issue'>Section&nbsp;5.2.3.1<span> (</span><span class='info'>Don't Issue Secrets to Clients with Inappropriate Security Policy</span><span>)</span></a>)
              
</li>
<li>
                パブリッククライアントに対しては明示的なユーザーの同意を必須とする.
                (<a class='info' href='#forced_user_consent'>Section&nbsp;5.2.3.2<span> (</span><span class='info'>Require User Consent for Public Clients without Secret</span><span>)</span></a>)
              
</li>
<li>
                クライアントインスタンス単位でシークレットを発行する.
                (<a class='info' href='#depl_specific_secretes'>Section&nbsp;5.2.3.4<span> (</span><span class='info'>Issue Installation-Specific Client Secrets</span><span>)</span></a>)
              
</li>
<li>
                クライアントシークレットの無効化を行う.
                (<a class='info' href='#client_secret_revocation'>Section&nbsp;5.2.3.6<span> (</span><span class='info'>Revoke Client Secrets</span><span>)</span></a>)
              
</li>
</ul><p>
          
</p>
<p>
            <br />
<br />

            攻撃例: クライアントインスタンス単位で異なるシークレットを取得
          
</p>
<p>
            アタッカーはクライアントインスタンス単位で異なるシークレットを, Webサイト (Webサーバー) や特定デバイス (ネイティブアプリケーション) から取得する可能性がある.
          
</p>
<p>
            対抗策:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                Webサーバーの場合: (設定ファイルやデータベースなどに) 標準的な保護策を行う.
                (<a class='info' href='#std_web'>Section&nbsp;5.3.2<span> (</span><span class='info'>Use Standard Web Server Protection Measures (for Config Files and Databases)</span><span>)</span></a>)
              
</li>
<li>
                ネイティブアプリケーションの場合: シークレットをローカルのセキュアストレージに保存する.
                (<a class='info' href='#secure_storage'>Section&nbsp;5.3.3<span> (</span><span class='info'>Store Secrets in Secure Storage</span><span>)</span></a>)
              
</li>
<li>
                クライアントシークレットを無効化する.
                (<a class='info' href='#client_secret_revocation'>Section&nbsp;5.2.3.6<span> (</span><span class='info'>Revoke Client Secrets</span><span>)</span></a>)
              
</li>
</ul><p>
          
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.2"></a><h3>4.1.2.&nbsp;
Threat: Obtaining Refresh Tokens</h3>

<p>
            クライアントタイプによっては, アタッカーにリフレッシュトークンが漏洩する経路としていくつかのパターンがある.
            各サブセクションではクライアントタイプごとにそれぞれの漏洩パターンおよび対抗策をまとめるが, まずは一般的な適用可能な対抗策について述べる.
          
</p>
<p>
            </p>
<ul class="text">
<li>
                認可サーバーはリフレッシュリクエスト毎にリフレッシュトークンとクライアントIDの紐付けを検証する.
                (<a class='info' href='#binding_refresh_client_id'>Section&nbsp;5.2.2.2<span> (</span><span class='info'>Binding of Refresh Token to &quot;client_id&quot;</span><span>)</span></a>)
              
</li>
<li>
                トークンのscopeを制限する.
                (<a class='info' href='#limit_scope'>Section&nbsp;5.1.5.1<span> (</span><span class='info'>Limit Token Scope</span><span>)</span></a>)
              
</li>
<li>
                リフレッシュトークンを無効化する.
                (<a class='info' href='#refresh_revocation'>Section&nbsp;5.2.2.4<span> (</span><span class='info'>Revocation of Refresh Tokens</span><span>)</span></a>)
              
</li>
<li>
                クライアントシークレットを無効化する.
                (<a class='info' href='#client_secret_revocation'>Section&nbsp;5.2.3.6<span> (</span><span class='info'>Revoke Client Secrets</span><span>)</span></a>)
              
</li>
<li>
                アクセストークンの不正利用が発覚した際に, リフレッシュトークンを置き換える.
                (<a class='info' href='#refresh_replace'>Section&nbsp;5.2.2.3<span> (</span><span class='info'>Refresh Token Rotation</span><span>)</span></a> の "Refresh Token Rotation" 参照)
              
</li>
</ul><p>
          
</p>
<p>
            <br />
<br />

            攻撃例: Webアプリケーションからリフレッシュトークンを取得
          
</p>
<p>
            アタッカーはWebアプリケーションの脆弱性を突いてリフレッシュトークンを取得する可能性がある.
          
</p>
<p>
            影響: Webアプリケーションでは複数ユーザーのアカウントが一括管理されているため, こういった攻撃によってそのサイト上のすべてのリフレッシュトークンが漏洩する可能性がある.
          
</p>
<p>
            対抗策:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                標準的なWebサーバーのセキュリティ対策を行う.
                (<a class='info' href='#std_web'>Section&nbsp;5.3.2<span> (</span><span class='info'>Use Standard Web Server Protection Measures (for Config Files and Databases)</span><span>)</span></a>)
              
</li>
<li>
                (クライアントアサーションやクライアントトークンなど) 強固なクライアント認証を行い, アタッカーがトークンリフレッシュを行うために必要なクライアントシークレットの漏洩を防ぐ.
                (<a class='info' href='#strong_client_authn'>Section&nbsp;5.2.3.7<span> (</span><span class='info'>Use Strong Client Authentication (e.g., client_assertion/client_token)</span><span>)</span></a>)
              
</li>
</ul><p>
          
</p>
<p>
            <br />
<br />

            攻撃例: ネイティブアプリケーションからリフレッシュトークンを取得
          
</p>
<p>
            ネイティブアプリケーションでは, リフレッシュトークンの漏洩は1ユーザーのみへの影響にとどまるケースがほとんどである.
          
</p>
<p>
            ローカルファイルシステムからの漏洩:
            アタッカーはデバイスのファイルシステムにアクセスし, リフレッシュトークンを取得する可能性がある.
            この攻撃のため, アタッカーは不正なアプリケーションを経由することがある.
          
</p>
<p>
            対抗策:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                シークレットをセキュアストレージに保存する.
                (<a class='info' href='#secure_storage'>Section&nbsp;5.3.3<span> (</span><span class='info'>Store Secrets in Secure Storage</span><span>)</span></a>)
              
</li>
<li>
                デバイスへの不正アクセスを防止するため, デバイスロック機能を利用する.
                (<a class='info' href='#device_lock'>Section&nbsp;5.3.4<span> (</span><span class='info'>Utilize Device Lock to Prevent Unauthorized Device Access</span><span>)</span></a>)
              
</li>
</ul><p>
          
</p>
<p>
            <br />
<br />

            攻撃例: デバイス盗難
          
</p>
<p>
            ホストとなるデバイス (携帯電話など) が盗難される可能性もある.
            このケースでは, アタッカーは被害ユーザーのすべてのアプリケーションにアクセスできる可能性がある.
          
</p>
<p>
            対抗策:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                デバイスへの不正アクセスを防止するため, デバイスロック機能を利用する.
                (<a class='info' href='#device_lock'>Section&nbsp;5.3.4<span> (</span><span class='info'>Utilize Device Lock to Prevent Unauthorized Device Access</span><span>)</span></a>)
              
</li>
<li>
                ユーザーがデバイス盗難に気づいた時点で, 影響のあるトークンを無効化できるようにする.
                (<a class='info' href='#refresh_revocation'>Section&nbsp;5.2.2.4<span> (</span><span class='info'>Revocation of Refresh Tokens</span><span>)</span></a>)
              
</li>
</ul><p>
          
</p>
<p>
            <br />
<br />

            攻撃例: デバイスコピー
          
</p>
<p>
            デバイス上の全データをその他のデバイスにコピーされる可能瀬がある.
            この場合, 後者のデバイスはあたかも前者のように振る舞う.
          
</p>
<p>
            対抗策:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                デバイスへの不正アクセスを防止するため, デバイスロック機能を利用する.
                (<a class='info' href='#device_lock'>Section&nbsp;5.3.4<span> (</span><span class='info'>Utilize Device Lock to Prevent Unauthorized Device Access</span><span>)</span></a>)
              
</li>
<li>
                トークンリフレッシュ時にデバイス自体の検証を行う.
                (<a class='info' href='#device_id'>Section&nbsp;5.2.2.5<span> (</span><span class='info'>Device Identification</span><span>)</span></a>)
              
</li>
<li>
                Refresh Token Rotateを用いる.
                (<a class='info' href='#refresh_replace'>Section&nbsp;5.2.2.3<span> (</span><span class='info'>Refresh Token Rotation</span><span>)</span></a>)
              
</li>
<li>
                ユーザーがデバイスコピーに気づいた時点で, 影響のあるトークンを無効化できるようにする.
                (<a class='info' href='#refresh_revocation'>Section&nbsp;5.2.2.4<span> (</span><span class='info'>Revocation of Refresh Tokens</span><span>)</span></a>)
              
</li>
</ul><p>
          
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.3"></a><h3>4.1.3.&nbsp;
Threat: Obtaining Access Tokens</h3>

<p>
            クライアントタイプによっては, アクセストークンがアタッカーに漏洩するいくつかのパターンがある.
            アクセストークンが他のアプリケーションからアクセス可能ななんらかのストレージデバイスに保存されている場合には, アクセストークンが盗まれる可能性もある.
          
</p>
<p>
            影響: トークンがbearer tokenであり, クライアント識別に付加的なメカニズムが用いられていない場合, アタッカーはそのトークンのscopeの範囲内でアクセスできるすべてのリソースにアクセス可能となる.
          
</p>
<p>
            対抗策:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                アクセストークンを一時的なメモリー空間に保存し, アクセス制限を行う.
                (<a class='info' href='#access_tokens'>Section&nbsp;5.1.6<span> (</span><span class='info'>Access Tokens</span><span>)</span></a>)
              
</li>
<li>
                トークンのscopeを制限する.
                (<a class='info' href='#limit_scope'>Section&nbsp;5.1.5.1<span> (</span><span class='info'>Limit Token Scope</span><span>)</span></a>)
              
</li>
<li>
                アクセストークンをプライベートメモリー内にとどめるか, リフレッシュトークンと同様の保護策を取る.
                (<a class='info' href='#refresh_tokens'>Section&nbsp;5.2.2<span> (</span><span class='info'>Refresh Tokens</span><span>)</span></a>)
              
</li>
<li>
                アクセストークンの有効期間を短くする.
                (<a class='info' href='#short_exp_time'>Section&nbsp;5.1.5.3<span> (</span><span class='info'>Use Short Expiration Time</span><span>)</span></a>)
              
</li>
</ul><p>
          
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.4"></a><h3>4.1.4.&nbsp;
Threat: End-User Credentials Phished Using Compromised or Embedded Browser</h3>

<p>
            不正なアプリケーションがエンドユーザーを騙し, 認可プロセスにおいてエンベッドブラウザを使ったフィッシング攻撃によりユーザーのパスワードを盗み取る可能性がある.
            またエンベッドブラウザの代わりに独自のユーザーインタフェースを用いる可能性も考えられる.
            このような方法では, TLSなどの視覚的な信頼メカニズムをバイパスすることができるのである.
            エンベッドもしくは内蔵クライアントインタフェースを用いる場合, クライアントアプリケーションが本来アクセス不可能であるはずの情報 (UID/password) へアクセスできる可能性がある.
          
</p>
<p>
            影響:
            クライアントアプリケーションもしくは通信自体が汚染されていると, ユーザーはそれに気がつかないであろう.
            またユーザーネームやパスワードなど, 認可処理の際にやりとりされるすべての情報を盗まれることとなる.
          
</p>
<p>
            対応策:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                OAuthフローはクライアントアプリケーションにパスワードが知られることなしに利用できるよう設計されている.
                クライアントはユーザーに直接クレデンシャルを尋ねるべきではない.
                加えて, OAuthは不正アプリケーションによる攻撃に対して保護策を施すものではなく, エンドユーザーのみがインストールするネイティブアプリケーションの信頼性についての責任を持っていることから, エンドユーザーにフィッシング攻撃や各種ベストプラクティスについて教育を施すことも重要であろう.
              
</li>
</ul><p>
          
</p>
<a name="open_redirector_client"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.5"></a><h3>4.1.5.&nbsp;
Threat: Open Redirectors on Client</h3>

<p>
            オープンリダイレクタとは, 何の検証もなしにパラメーターとして指定された場所に対してユーザーエージェントをリダイレクトさせるエンドポイントのことである.
            認可サーバーがクライアントに部分的なリダイレクトURIの登録 (訳注: Hostのみ, Pathの一部のみなど) を許す場合, アタッカーはクライアントが持つオープンリダイレクタを悪用し, 認可サーバーの検証をすり抜けて認可コードまたはアクセストークンを自身のコントロール下にあるエンドポイントに送信することが可能となる.
          
</p>
<p>
            影響: アタッカーは認可コードやアクセストークンにアクセスすることが可能になる.
          
</p>
<p>
            対抗策:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                クライアントにリダイレクトURI全体を事前登録させる.
                (<a class='info' href='#val_redirect'>Section&nbsp;5.2.3.5<span> (</span><span class='info'>Validate Pre-Registered &quot;redirect_uri&quot;</span><span>)</span></a>)
              
</li>
</ul><p>
          
</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Authorization Endpoint</h3>

<p>
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.1"></a><h3>4.2.1.&nbsp;
Threat: Password Phishing by Counterfeit Authorization Server</h3>

<p>
            OAuthは認可サーバーの真正性検証は行わない.
            悪意ある者はこれを逆手に取って, クライアントのリクエストを遮り, 誤った, 場合によっては不正なレスポンスを返すことができる.
            この攻撃はDNSやAddress Resolution Protocol (ARP) のなりすまし (spoofing) によって実現できる.
            OAuthや類似プロトコルは, ユーザーに対してリダイレクトされた先でパスワードを入力するという行為に慣らすという側面も持つ.
            そのためユーザーが注意を怠ると, Webサイトの真正性を確認せずにクレデンシャルを入力してしまうことになり, アタッカーにユーザーのパスワードを盗む機会を与えることとなる.
          
</p>
<p>
            対抗策:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                認可サーバーはOAuth実装時にこのようなアタックを考慮し, 認可サーバーやレスポンスの真正性が問題となるすべてのリクエストにおいてTLSを必須とすべきである.
                (<a class='info' href='#server_authn'>Section&nbsp;5.1.2<span> (</span><span class='info'>Utilize Server Authentication</span><span>)</span></a>)
              
</li>
<li>
                認可サーバーはユーザーに対してフィッシング攻撃のリスクを教育し, ユーザーに認可サーバーの真正性を簡単に確認する手段を提供すべきである.
              
</li>
</ul><p>
          
</p>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.2"></a><h3>4.2.2.&nbsp;
Threat: User Unintentionally Grants Too Much Access Scope</h3>

<p>
            エンドユーザーの認可を受ける際, エンドユーザーは要求されたscopeおよび認可相手を理解していない場合もありうる.
            本来許可されるべきでないリソースへのアクセスを, 許可してしまうこともあるであろう.
          
</p>
<p>
            対抗策:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                ユーザーに対して要求されたscope (リソースおよびパーミッション) についての分かりやすい説明を行う.
                (<a class='info' href='#informed_decisions'>Section&nbsp;5.2.4.2<span> (</span><span class='info'>Informed Decisions Based on Transparency</span><span>)</span></a>)
              
</li>
<li>
                クライアントごとに要求できるscopeを制限する.
                認可サーバーはクライアント識別子ごとにscopeを制御することを検討してもよい.
                なお, このような意思決定はクライアントと認可サーバーの間で行われるものであり, OAuthの定めるところではない.
                認可サーバーは, パブリッククライアントのscopeを狭めるなど, クライアントタイプごとに要求できるscopeを制限しても良い.
                (<a class='info' href='#limit_scope'>Section&nbsp;5.1.5.1<span> (</span><span class='info'>Limit Token Scope</span><span>)</span></a>)
              
</li>
</ul><p>
          
</p>
<a name="mal_client3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.3"></a><h3>4.2.3.&nbsp;
Threat: Malicious Client Obtains Existing Authorization by Fraud</h3>

<p>
            認可サーバーは既に同意済みのクライアントからの認可リクエストを自動承認することも考えられる.
            ユーザーが認可サーバーの認可エンドポイントにリダイレクトされた際, 認可サーバーはそのユーザーが既にそのクライアントに対してアクセスを許可していることを検知し, その場合はユーザーに同意画面を表示することなく自動的にクライアントに戻すことができる.
          
</p>
<p>
            不正なクライアントはこの機能を悪用し, 正規クライアントの代わりにここで得られる認可コードなどを取得する可能性がある.
          
</p>
<p>
            対抗策:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                認可サーバーは, クライアントが事前登録したリダイレクトURIが検証可能でない限り, パブリッククライアントに対して自動認可処理を行うべきではない.
                (<a class='info' href='#val_redirect'>Section&nbsp;5.2.3.5<span> (</span><span class='info'>Validate Pre-Registered &quot;redirect_uri&quot;</span><span>)</span></a>)
              
</li>
<li>
                認可サーバーは自動承認時に取得できるscopeを狭めることで, リスクを軽減できる.
                (<a class='info' href='#limit_scope'>Section&nbsp;5.1.5.1<span> (</span><span class='info'>Limit Token Scope</span><span>)</span></a>)
              
</li>
</ul><p>
          
</p>
<a name="open_redirector"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.4"></a><h3>4.2.4.&nbsp;
Threat: Open Redirector</h3>

<p>
            アタッカーは認可エンドポイントとリダイレクトURIパラメーターを使って, 認可サーバーをオープンリダイレクタとして利用することができる.
            オープンリダイレクタとは, 何の検証もなしにパラメーターとして指定された場所に対してユーザーエージェントをリダイレクトさせるエンドポイントのことである.
          
</p>
<p>
            影響: アタッカーはユーザーの認可サーバーに対する信頼を逆手に取り, フィッシング攻撃を仕掛けることができる.
          
</p>
<p>
            対抗策:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                クライアントにリダイレクトURI全体を事前登録させる.
                (<a class='info' href='#val_redirect'>Section&nbsp;5.2.3.5<span> (</span><span class='info'>Validate Pre-Registered &quot;redirect_uri&quot;</span><span>)</span></a>)
              
</li>
<li>
                クライアント識別子やリダイレクトURIが検証されない限り, リダイレクトURIへのリダイレクトを行わない.
                (<a class='info' href='#val_redirect'>Section&nbsp;5.2.3.5<span> (</span><span class='info'>Validate Pre-Registered &quot;redirect_uri&quot;</span><span>)</span></a>)
              
</li>
</ul><p>
          
</p>
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Token Endpoint</h3>

<p>
</p>
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.1"></a><h3>4.3.1.&nbsp;
Threat: Eavesdropping Access Tokens</h3>

<p>
            アタッカーは認可サーバーとクライアントの通信を盗聴し, アクセストークンを取得する可能性がある.
          
</p>
<p>
            影響: アタッカーは該当アクセストークンの持つscopeの範囲内でアクセスできるすべてのリソースにアクセス可能になる.
          
</p>
<p>
            対抗策:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                OAuth仕様に従って, 認可サーバーは通信がTLSで保護されていることを保証する必要がある.
                (<a class='info' href='#conf_requests'>Section&nbsp;5.1.1<span> (</span><span class='info'>Ensure Confidentiality of Requests</span><span>)</span></a>)
              
</li>
<li>
                end-to-endの秘匿性が保たれない場合, アクセストークンのscopeを狭めたり有効期限を短くしたりすることで, 漏洩時のリスクを軽減できる.
                (<a class='info' href='#limit_scope'>Section&nbsp;5.1.5.1<span> (</span><span class='info'>Limit Token Scope</span><span>)</span></a>, <a class='info' href='#short_exp_time'>Section&nbsp;5.1.5.3<span> (</span><span class='info'>Use Short Expiration Time</span><span>)</span></a>)
              
</li>
</ul><p>
          
</p>
<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.2"></a><h3>4.3.2.&nbsp;
Threat: Obtaining Access Tokens from Authorization Server Database</h3>

<p>
            認可サーバーがhandleベースのアクセストークンを用いてそれをデータベースに保存している場合, この攻撃が可能になる.
            アタッカーはSQLインジェクションによって認可サーバーのデータベースアクセスを取得する可能性がある.
          
</p>
<p>
            影響: 全アクセストークンの漏洩
          
</p>
<p>
            対抗策:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                システムレベルのセキュリティ対策を行う.
                (<a class='info' href='#std_sys'>Section&nbsp;5.1.4.1.1<span> (</span><span class='info'>Enforce Standard System Security Means</span><span>)</span></a>)
              
</li>
<li>
                アクセストークンのhash値のみを保存する.
                (<a class='info' href='#noclear'>Section&nbsp;5.1.4.1.3<span> (</span><span class='info'>No Cleartext Storage of Credentials</span><span>)</span></a>)
              
</li>
<li>
                標準的SQLインジェクション対策を行う.
                (<a class='info' href='#std_sql'>Section&nbsp;5.1.4.1.2<span> (</span><span class='info'>Enforce Standard SQL Injection Countermeasures</span><span>)</span></a>)
              
</li>
</ul><p>
          
</p>
<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.3"></a><h3>4.3.3.&nbsp;
Threat: Disclosure of Client Credentials during Transmission</h3>

<p>
            アタッカーは, クライアント認証時やOAuthトークンリクエスト時に, クライアント・サーバー間を送信されるクライアントクレデンシャルを盗聴することができる.
          
</p>
<p>
            影響: クライアントクレデンシャルの漏洩は, クライアントサービスのフィッシングやなりすまし (impersonation) を容易にする.
          
</p>
<p>
            対抗策:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                クライアントクレデンシャル送信時はTLSを用いる.
                (<a class='info' href='#conf_requests'>Section&nbsp;5.1.1<span> (</span><span class='info'>Ensure Confidentiality of Requests</span><span>)</span></a>)
              
</li>
<li>
                クレデンシャルを平文で送信する必要の無い認証方式を採用する.
                (HMACなど)
              
</li>
</ul><p>
          
</p>
<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.4"></a><h3>4.3.4.&nbsp;
Threat: Obtaining Client Secret from Authorization Server Database</h3>

<p>
            アタッカーは, SQLインジェクション攻撃によって, 正規のclient_id/secretペアを認可サーバーのデータベースから盗み出すことができる.
          
</p>
<p>
            影響: 全client_id/secretペアの漏洩. これはアタッカーにいかなる正規クライアントとしても動作することを許可する.
          
</p>
<p>
            対抗策:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                システムレベルのセキュリティ対策を行う.
                (<a class='info' href='#std_sys'>Section&nbsp;5.1.4.1.1<span> (</span><span class='info'>Enforce Standard System Security Means</span><span>)</span></a>)
              
</li>
<li>
                標準的SQLインジェクション対策を行う.
                (<a class='info' href='#std_sql'>Section&nbsp;5.1.4.1.2<span> (</span><span class='info'>Enforce Standard SQL Injection Countermeasures</span><span>)</span></a>)
              
</li>
<li>
                "Enforce Credential Storage Protection Best Practices" に従って適切にクレデンシャルを扱う.
                (<a class='info' href='#cred_storage_prot'>Section&nbsp;5.1.4.1<span> (</span><span class='info'>Enforce Credential Storage Protection Best Practices</span><span>)</span></a>)
              
</li>
</ul><p>
          
</p>
<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.5"></a><h3>4.3.5.&nbsp;
Threat: Obtaining Client Secret by Online Guessing</h3>

<p>
            アタッカーは正規のclient_id/secretペアを推測できる.
          
</p>
<p>
            影響: 単一client_id/secretペアの漏洩.
          
</p>
<p>
            対抗策:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                高エントロピーなシークレットを利用する.
                (<a class='info' href='#high_entropy'>Section&nbsp;5.1.4.2.2<span> (</span><span class='info'>Use High Entropy for Secrets</span><span>)</span></a>)
              
</li>
<li>
                アカウントをロックする.
                (<a class='info' href='#lock_accounts'>Section&nbsp;5.1.4.2.3<span> (</span><span class='info'>Lock Accounts</span><span>)</span></a>)
              
</li>
<li>
                強固なクライアント認証を行う.
                (<a class='info' href='#strong_client_authn'>Section&nbsp;5.2.3.7<span> (</span><span class='info'>Use Strong Client Authentication (e.g., client_assertion/client_token)</span><span>)</span></a>)
              
</li>
</ul><p>
          
</p>
<a name="anchor30"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
Obtaining Authorization</h3>

<p>
          本セクションでは, アクセストークン取得時の各フローにおいて発生する脅威について述べる.
          それぞれのフローは, 認可エンドポイントおよびトークンエンドポイントにおけるレスポンスタイプとグラントタイプによって分類される.
        
</p>
<a name="code_flow"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.1"></a><h3>4.4.1.&nbsp;
Authorization &quot;code&quot;</h3>

<a name="eavesdropping"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.1.1"></a><h3>4.4.1.1.&nbsp;
Threat: Eavesdropping or Leaking Authorization &quot;codes&quot;</h3>

<p>
              アタッカーにより, 認可サーバーとクライアントの間の通信を盗聴され, 認可コードが漏洩する可能性がある.
              加えて認可コードはブラウザ経由で送信されるので, その他の方法で意図せず信頼できないサイトやアタッカーに漏洩する可能性がある.
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  リファラヘッダー: ブラウザにより, Webページ内にembedされたコンテンツのロード時やページ遷移時に, "referer" ヘッダーが付与される.
                  これはヘッダー送信の対象サイトが元のサイトと信頼関係にない場合でも送信されうる.
                  リファラーヘッダーはトラフィック解析のためログに残されることが多い.
                
</li>
<li>
                  リクエストログ: Webサーバー上のリクエストログには, 一般的にリクエスト中のクエリーパラメータが含まれる.
                
</li>
<li>
                  オープンリダイレクタ: Webサイトはしばしばリダイレクタを通じてユーザーを別のサイトに遷移させる.
                  オープンリダイレクタは検証コード (訳注: 認可コードのことを指すと思われる) の漏洩の原因となりうる.
                
</li>
<li>
                  ブラウザ履歴: Webブラウザは一般的に訪問履歴を記録する.
                  同じブラウザを利用する場合, 過去に他のユーザーが訪問したURLが他者に漏洩する可能性がある.
                
</li>
</ul><p>
              注: SAMLプロトコル仕様 <a class='info' href='#OASIS.sstc-saml-bindings-1.1'>[OASIS.sstc&#8209;saml&#8209;bindings&#8209;1.1]<span> (</span><span class='info'>Maler, E., Ed., Mishra, P., Ed., and R. Philpott, Ed., &ldquo;Bindings and Profiles for the OASIS Security Assertion Markup           Language (SAML) V1.1,&rdquo; September&nbsp;2003.</span><span>)</span></a> Section 4.1.1.9.1 および <a class='info' href='#OASIS.sstc-sec-analysis-response-01'>[OASIS.sstc&#8209;sec&#8209;analysis&#8209;response&#8209;01]<span> (</span><span class='info'>Linn, J., Ed. and P. Mishra, Ed., &ldquo;SSTC Response to &ldquo;Security Analysis of the SAML Single           Sign-on Browser/Artifact Profile&rdquo;,&rdquo; January&nbsp;2005.</span><span>)</span></a> にこれらと同様の攻撃に関する記述がある.
            
</p>
<p>
              対抗策:
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  OAuth Core仕様にあるように, 認可サーバーおよびクライアントは, 通信がTLSなどのトランスポートレイヤーメカニズムによって保護されていることを保証しなければならない.
                  (<a class='info' href='#conf_requests'>Section&nbsp;5.1.1<span> (</span><span class='info'>Ensure Confidentiality of Requests</span><span>)</span></a>)
                
</li>
<li>
                  認可サーバーがクライアントに可能な限りクライアント認証を要求することで, 認可コードと対象クライアントとの紐付けを検証することができる.
                  (<a class='info' href='#bind_code_client_id'>Section&nbsp;5.2.4.4<span> (</span><span class='info'>Binding of Authorization &quot;code&quot; to &quot;client_id&quot;</span><span>)</span></a>)
                
</li>
<li>
                  認可コードの有効期間を短くする. (<a class='info' href='#short_exp_time'>Section&nbsp;5.1.5.3<span> (</span><span class='info'>Use Short Expiration Time</span><span>)</span></a>)
                
</li>
<li>
                  認可サーバーは認可コードをOne-timeトークンとして扱う. (<a class='info' href='#one_time_usage'>Section&nbsp;5.1.5.4<span> (</span><span class='info'>Limit Number of Usages or One-Time Usage</span><span>)</span></a>)
                
</li>
<li>
                  認可サーバーが認可コードが複数回使われたことを検知した場合, その認可コードを用いて発行されたすべてのトークンを無効化することも検討できる.
                  (<a class='info' href='#automatic_code_revocation'>Section&nbsp;5.2.1.1<span> (</span><span class='info'>Automatic Revocation of Derived Tokens If Abuse Is Detected</span><span>)</span></a>)
                
</li>
<li>
                  以上のような対抗策が実施できない場合は, アクセストークンのscopeを狭め, 有効期間を短くすることで, リスクを軽減できる.
                  (<a class='info' href='#limit_scope'>Section&nbsp;5.1.5.1<span> (</span><span class='info'>Limit Token Scope</span><span>)</span></a>, <a class='info' href='#short_exp_time'>Section&nbsp;5.1.5.3<span> (</span><span class='info'>Use Short Expiration Time</span><span>)</span></a>)
                
</li>
<li>
                  クライアントサイトはリダイレクトURIに対するブラウザキャッシュをクリアするため, ページをリロードすることを検討してもよい.
                
</li>
</ul><p>
            
</p>
<a name="anchor31"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.1.2"></a><h3>4.4.1.2.&nbsp;
Threat: Obtaining Authorization &quot;codes&quot; from Authorization Server Database</h3>

<p>
              認可サーバーがhandleとして認可コードをデータベースに保存した場合, この脅威が発生しうる.
              アタッカーは, データベースへのアクセス権限を不正取得したり, SQLインジェクション攻撃を通じて, 認可サーバーのデータベース中から認可コードを取得できる可能性がある.
            
</p>
<p>
              影響: 全認可コードが漏洩し, おそらくさらにそれに紐づくredirect_uriとclient_idも漏洩する.
            
</p>
<p>
              対抗策:
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  クレデンシャルストレージを保護するためのベストプラクティスに従う.
                  (<a class='info' href='#cred_storage_prot'>Section&nbsp;5.1.4.1<span> (</span><span class='info'>Enforce Credential Storage Protection Best Practices</span><span>)</span></a>)
                
</li>
<li>
                  システムレベルのセキュリティ対策を行う.
                  (<a class='info' href='#std_sys'>Section&nbsp;5.1.4.1.1<span> (</span><span class='info'>Enforce Standard System Security Means</span><span>)</span></a>)
                
</li>
<li>
                  アクセストークンのハッシュ値のみを保存する.
                  (<a class='info' href='#noclear'>Section&nbsp;5.1.4.1.3<span> (</span><span class='info'>No Cleartext Storage of Credentials</span><span>)</span></a>)
                
</li>
<li>
                  標準的SQLインジェクション対策を行う.
                  (<a class='info' href='#std_sql'>Section&nbsp;5.1.4.1.2<span> (</span><span class='info'>Enforce Standard SQL Injection Countermeasures</span><span>)</span></a>)
                
</li>
</ul><p>
            
</p>
<a name="anchor32"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.1.3"></a><h3>4.4.1.3.&nbsp;
Threat: Online Guessing of Authorization &quot;code&quot;s</h3>

<p>
              アタッカーが正規の認可コード値を推測し, 推測値を "code" グラントとして用いてアクセストークンを取得する可能性がある.
            
</p>
<p>
              影響: 単一のアクセストークン, およびおそらくはそれと紐づいたリフレッシュトークンの漏洩・不正取得.
            
</p>
<p>
              対抗策:
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  handleベーストークンは高エントロピーでなければならない.
                  (<a class='info' href='#high_entropy'>Section&nbsp;5.1.4.2.2<span> (</span><span class='info'>Use High Entropy for Secrets</span><span>)</span></a>)
                
</li>
<li>
                  assertionベーストークンは署名されるべきである.
                  (<a class='info' href='#signed_tokens'>Section&nbsp;5.1.5.9<span> (</span><span class='info'>Sign Self-Contained Tokens</span><span>)</span></a>)
                
</li>
<li>
                  クライアント認証を行う.
                  これによりアタッカーが推測しなければならない値が増える.
                  (<a class='info' href='#depl_specific_secretes'>Section&nbsp;5.2.3.4<span> (</span><span class='info'>Issue Installation-Specific Client Secrets</span><span>)</span></a>)
                
</li>
<li>
                  認可コードをリダイレクトURIと紐づける.
                  これによりアタッカーが推測しなければならない値が増える.
                  (<a class='info' href='#bind_code_redirect'>Section&nbsp;5.2.4.5<span> (</span><span class='info'>Binding of Authorization &quot;code&quot; to &quot;redirect_uri&quot;</span><span>)</span></a>)
                
</li>
<li>
                  トークンの有効期間を短くする.
                  (<a class='info' href='#short_exp_time'>Section&nbsp;5.1.5.3<span> (</span><span class='info'>Use Short Expiration Time</span><span>)</span></a>)
                
</li>
</ul><p>
            
</p>
<a name="mal_client"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.1.4"></a><h3>4.4.1.4.&nbsp;
Threat: Malicious Client Obtains Authorization</h3>

<p>
              不正クライアントが正規クライアントになりすましてアクセス認可を取得する可能性がある.
              不正クライアントによってはスクレイピングなどによりユーザーの同意フローをシミュレートすることも考えられる.
            
</p>
<p>
              推測: ユーザーのデバイスを不正なソフトウェアから保護する責務は認可サーバーにはない.
              これは該当デバイス上で動作するプラットフォームの責務であり, プラットフォームはおそらく協調動作する (アプリケーションマネージメントインフラなどの) エコシステムと共同で, その任にあたるであろう.
              認可サーバーが単体として責任を持つのは, リソースサーバー上のエンドユーザーのリソースに対するアクセス制御, およびOAuthプロトコルを通じたそれらへの不正アクセスの防止である.
              この前提に基づき, ここで扱う脅威に対する対抗策として, 以下が考えられる.
            
</p>
<p>
              対抗策:
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  認可サーバーは可能な限りクライアント認証を行うべきである. (<a class='info' href='#depl_specific_secretes'>Section&nbsp;5.2.3.4<span> (</span><span class='info'>Issue Installation-Specific Client Secrets</span><span>)</span></a>)
                  注: クライアント認証はエンドユーザーの認可プロセスの後に実施される.
                
</li>
<li>
                  認可サーバーは, 事前登録されたリダイレクトURIがあれば, それを用いてクライアントが指定したリダイレクトURIを検証するべきである.
                  (<a class='info' href='#val_redirect'>Section&nbsp;5.2.3.5<span> (</span><span class='info'>Validate Pre-Registered &quot;redirect_uri&quot;</span><span>)</span></a>)
                  注: 不正なリダイレクトURIは不正クライアントによるアクセスを予測させるが, 正しいリダイレクトURIが正規のクライアントによるアクセスを保証する分けではないことに注意すること.
                  リダイレクトURIの信頼性は, クライアントタイプに依存する.
                  Webアプリケーションの場合, そのリダイレクトURIはグローバルにユニークかつFQDNがHTTPSサーバー認証を通じて検証されるため高い信頼を置ける.
                  一方ネイティブクライアントでは, リダイレクトURIは多くの場合デバイスローカルなリソース (カスタムスキーマなど) を指す.
                  よって, あるデバイス上では不正クライアントが正規クライアントのリダイレクトURIを利用可能であるような状況も考えられる.
                
</li>
<li>
                  エンドユーザーを認証した後, 認可サーバーは該当ユーザーに同意を求めるべきである.
                  ここで認可サーバーはクライアントによるアクセスの目的, scope, および認可の有効期間をエンドユーザーに示すべきである.
                  さらに, 認可サーバーはユーザーにクライアントの身元を示すいかなる情報をも提示すべきである.
                  ここで示される情報を使った特定アプリケーションの検証, および認可リクエストの許可/拒否の決定については, ユーザーに委ねられる.
                  (<a class='info' href='#validation_end_user'>Section&nbsp;5.2.4.3<span> (</span><span class='info'>Validation of Client Properties by End User</span><span>)</span></a>)
                
</li>
<li>
                  認可サーバーは, 信頼できる方法によって認証もしくは検証されたクライアント以外に対しては, 自動再承認処理を行うべきではない.
                  (<a class='info' href='#automatic_processing'>Section&nbsp;5.2.4.1<span> (</span><span class='info'>Automatic Processing of Repeated Authorizations Requires Client Validation</span><span>)</span></a>)
                
</li>
<li>
                  認可サーバーがエンドユーザーの自動認証を行う場合, スクレイピングを防ぐ手段がなくなる可能性がある.
                  こういった手段としては, CAPTCHAsや各種マルチファクター認証技術などが挙げられる.
                
</li>
<li>
                  認可サーバーは, 信頼できる方法によって認証できないクライアントに対しては, 発行するトークンのスコープを制限することもありうる.
                  (<a class='info' href='#limit_scope'>Section&nbsp;5.1.5.1<span> (</span><span class='info'>Limit Token Scope</span><span>)</span></a>)
                
</li>
</ul><p>
            
</p>
<a name="anchor33"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.1.5"></a><h3>4.4.1.5.&nbsp;
Threat: Authorization &quot;code&quot; Phishing</h3>

<p>
              悪意あるアプリケーションがクライアントサイトになりすまし, 認可コードを取得する可能性がある.
              DNSやARPのなりすましがその要因となる.
              このような脅威は, Webアプリケーション型のクライアントにあてはまる.
              そのようなクライアントのリダイレクトURIは, ユーザのブラウザが動作するローカルホストではない別の場所を指すためである.
            
</p>
<p>
              影響: この脅威はWebアプリケーションにあてはまり, 認可コード, そして潜在的にはそれに紐づくアクセストークンおよびリフレッシュトークンの漏洩につながる.
            
</p>
<p>
              対抗策:
            
</p>
<p>
              このような攻撃を防ぐため, 以下のいずれかの対策を講じることを強く推奨する.
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  クライアントのリダイレクトURIは, HTTPSで保護されたエンドポイントを指すべきである.
                  またブラウザのサーバー認証機能を用いて, 確実にそのリダイレクトURIを認証すべきである.
                  (<a class='info' href='#server_authn'>Section&nbsp;5.1.2<span> (</span><span class='info'>Utilize Server Authentication</span><span>)</span></a>)
                
</li>
<li>
                  認可サーバーはクライアント認証を要求するべきである.
                  それにより認可コードと特定のクライアントとの紐付けが, 信頼できる方法で検証可能となる.
                  (<a class='info' href='#bind_code_client_id'>Section&nbsp;5.2.4.4<span> (</span><span class='info'>Binding of Authorization &quot;code&quot; to &quot;client_id&quot;</span><span>)</span></a>)
                
</li>
</ul><p>
            
</p>
<a name="anchor34"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.1.6"></a><h3>4.4.1.6.&nbsp;
Threat: User Session Impersonation</h3>

<p>
              悪意あるアプリケーションがクライアントサイトになりすまし, クライアント上のユーザーセッションを偽装する可能性がある.
              DNSやARPのなりすましがその要因となる.
              このような脅威は, Webアプリケーション型のクライアントにあてはまる.
              そのようなクライアントのリダイレクトURIは, ユーザのブラウザが動作するローカルホストではない別の場所を指すためである.
            
</p>
<p>
              影響: ブラウザ経由でコールバックエンドポイントに送信される認可コードがアタッカーに漏洩する.
              アタッカーは, そこでフローを中断し, 得られた認可コードを抜き出して自らクライアントに送ることで, 保護リソースへのアクセス権限を得る.
              クライアントは渡された認可コードをそのままアクセストークンと交換し, 得られたアクセストークンを使って保護リソースアクセスを行う.
              これによってアタッカーは被害者の管理下にある保護リソースを取得したり, それを書き換えたりすることで, なんらかの利益を得る.
              (サードパーティーSNS上のログインボタンなどのように) OAuthが認証処理の委譲の為に用いられている場合, アタッカーは得られた認可コードを使って被害者としてクライアントにログインできる.
            
</p>
<p>
              注: 認可コードをアクセストークンと交換する際のクライアント認証は, この攻撃を防ぐためには利用できない.
              このケースでは, トークンを取得するのはあくまで正規のクライアントである.
            
</p>
<p>
              対抗策:
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  エンドユーザーセッションの偽装を防ぐには, クライアントのリダイレクトURIは, HTTPSで保護されたエンドポイントを指すべきである.
                  またブラウザのサーバー認証機能を用いて, 確実にそのリダイレクトURIを認証すべきである.
                  (<a class='info' href='#server_authn'>Section&nbsp;5.1.2<span> (</span><span class='info'>Utilize Server Authentication</span><span>)</span></a>)
                
</li>
</ul><p>
            
</p>
<a name="authz_code_leakage"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.1.7"></a><h3>4.4.1.7.&nbsp;
Threat: Authorization &quot;code&quot; Leakage through Counterfeit Client</h3>

<p>
              この攻撃では, アタッカーは認可コードグラントタイプを悪用し, 別のユーザー (被害者) に認可サーバーへのログインおよび被害者自身のリソースへのアクセス許可を行わせ, 得られた認可コードをアタッカーのアカウントを使ってクライアントに渡す.
              被害者によるリソースへのアクセス認可を, クライアントサイト上のアタッカーアカウントと紐づけることが, その目的である.
            
</p>
<p>
              アタッカーは既存クライアントを悪用し, それを自身の悪意あるサイトと組み合わせて利用する.
              これは被害者の「クライアントアプリケーションは特定のリソースサーバーへのアクセスを要求しているのだろう」という思い込みを利用した攻撃である.
              被害者は正規クライアントから発行された正常なリクエストを目にするため, そのリクエストを受理するであろう.
              そしてアタッカーは被害者が知らず知らずのうちに認可してしまった情報へのアクセス権限を得るのである.
            
</p>
<p>
              この攻撃は以下のフローで行われる.
            
</p>
<p>
              </p>
<ol class="text">
<li>
                  アタッカーはクライアントサイト (もしくはクライアントアプリケーション) にアクセスし, 特定のリソースサーバーへのデータアクセスを行う.
                  クライアントWebサイトはそれを受けて, リソースサーバーに対応する認可サーバーへ, 認可リクエストを行う.
                  ここでアタッカーはこの認可プロセスを途中で止め, 認可サーバーの認可エンドポイントに自身のコントロール下にあるWebサイト上のリダイレクトURIを付与する.
                
</li>
<li>
                  アタッカーは改竄された認可エンドポイントURLを (emailやブログ記事中のリンクなどを経由して) 被害者に開かせる.
                  被害者に該当URLを開かせる手段については, ここでは特に限定しない.
                
</li>
<li>
                  リンクをクリックすることで, 被害者は認証を要求され, その後クライアントによるリソースアクセスへの同意を求められる.
                
</li>
<li>
                  認可プロセスが完了すると, 認可サーバーはユーザーエージェントを元のクライアントではなくアタッカーのWebサイトにリダイレクトさせる.
                
</li>
<li>
                  それによりアタッカーはなんらかの方法で該当認可コードを得る.
                  その具体的な手段についてはここでは触れない.
                
</li>
<li>
                  その後アタッカーは対象Webサイト (もしくはアプリケーション) の本来のリダイレクトURIに得られた認可コードを付与し, 自身のユーザーエージェントでそのURLをロードする.
                  これにより認可コードは元のクライアントサイト (もしくはアプリケーション) に渡される.
                
</li>
<li>
                  クライアントサイトは得られた認可コードをアクセストークンと交換し, それを自身のサイト上のアタッカーのアカウントと紐づける.
                
</li>
<li>
                  以上により, アタッカーは該当クライアントサイトを通じて被害者のリソースへのアクセス権限を得る.
                
</li>
</ol><p>
            
</p>
<p>
              影響: アタッカーはクライアントサイト上の自身のアカウントを通じて被害者のリソースへのアクセス権限を得る.
            
</p>
<p>
              対抗策:
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  アタッカーは認可フローを途中でインターセプトするため, 外部サイトのリダイレクトURIを利用する必要がある.
                  よって認可サーバーが, 認可コードをその認可リクエスト時に指定されたリダイレクトURIと紐づけ, そのリダイレクトURIを用いてトークンエンドポイントで再び送られてくるリダイレクトURIを検証することで, この攻撃を検知することができる.
                  (<a class='info' href='#bind_code_redirect'>Section&nbsp;5.2.4.5<span> (</span><span class='info'>Binding of Authorization &quot;code&quot; to &quot;redirect_uri&quot;</span><span>)</span></a>)
                
</li>
<li>
                  さらに, 認可サーバーはリダイレクトURIの事前登録およびその検証を必須とすることもできる. (<a class='info' href='#val_redirect'>Section&nbsp;5.2.3.5<span> (</span><span class='info'>Validate Pre-Registered &quot;redirect_uri&quot;</span><span>)</span></a>)
                  これによりさらに早い段階で不正クライアントへの認可コード漏洩を検知することができる.
                
</li>
<li>
                  ネイティブアプリケーションの場合, 認可コードとクライアントIDの紐付けに加え, 各インスタンスごとに固有のクライアントID & シークレットを用いることもできる.
                  (<a class='info' href='#bind_code_client_id'>Section&nbsp;5.2.4.4<span> (</span><span class='info'>Binding of Authorization &quot;code&quot; to &quot;client_id&quot;</span><span>)</span></a>, <a class='info' href='#depl_specific_secretes'>Section&nbsp;5.2.3.4<span> (</span><span class='info'>Issue Installation-Specific Client Secrets</span><span>)</span></a>)
                  アタッカーはインスタンス固有のシークレットへアクセスできないため, アタッカーが認可コードをトークンと交換することは不可能になる.
                
</li>
<li>
                  クライアントは, この攻撃に対して脆弱なフローの代わりに, implicitグラントタイプやリソースオーナーパスワードグラントタイプなどの別フローを用いることもできる.
                  (<a class='info' href='#implicit_flow'>Section&nbsp;4.4.2<span> (</span><span class='info'>Implicit Grant</span><span>)</span></a>, <a class='info' href='#pwd_flow'>Section&nbsp;4.4.3<span> (</span><span class='info'>Resource Owner Password Credentials</span><span>)</span></a>)
                  (訳注: implicitグラントタイプやリソースオーナーパスワードグラントタイプは, 別の攻撃に対して脆弱な一面があることに注意すること)
                
</li>
</ul><p>
            
</p>
<a name="section_csrf"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.1.8"></a><h3>4.4.1.8.&nbsp;
Threat: CSRF Attack against redirect-uri</h3>

<p>
              Cross-site request forgery (CSRF) は, Webサイトに信頼もしくは認証されたユーザーを通じてHTTPリクエストを実行させる, Webベースの攻撃である.
              攻撃にはHTTPリダイレクトやHTMLフォームなどが用いられる.
              OAuth認可フローに対するCSRF攻撃は, アタッカーがOAuthの保護リソースへのアクセス権限を取得する際に, ユーザー同意ステップをスキップすることを可能にする.
            
</p>
<p>
              この攻撃は認可コードフロー中でリダイレクトURIに対して行われる.
              アタッカーは, 自身の保護リソースに対する認可を行い, 認可コードを取得する.
              その後アタッカーは自身のデバイス上でクライアントへのリダイレクトを途中で止め, 被害者にそのリダイレクトリクエストを実行させる.
              リダイレクトを受けたクライアントは, 認可サーバーからトークンを取得し, クライアント上の被害者セッションとそのトークンでアクセスできるリソースを紐づける.
            
</p>
<p>
              影響: 被害者はアタッカーの代理としてリソースアクセスを行う.
              その栄養はアクセスされるリソースに依存するが, 例えば被害者がアタッカーのリソースとしてプライベートなデータをアップロードするケースなどが考えられる.
              OAuthを3rd partyログインの為に用いている場合, クライアント上の被害者アカウントが外部Identity Provider上のアタッカーアカウントと紐づけられてしまい, アタッカーが別デバイス上で被害者としてクライアントにログインできるようになってしまう, といったケースも考えられる.
            
</p>
<p>
              対抗策:
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  認可リクエストとそのリダイレクトレスポンスを紐づけるため, stateパラメーターを利用すべきである.
                  (<a class='info' href='#link_state_uasession'>Section&nbsp;5.3.5<span> (</span><span class='info'>Link the &quot;state&quot; Parameter to User Agent Session</span><span>)</span></a>)
                
</li>
<li>
                  クライアント開発者とエンドユーザーに, 信頼できないURLにアクセスすべきでないと教育するといったことも考えられる.
                
</li>
</ul><p>
            
</p>
<a name="anchor35"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.1.9"></a><h3>4.4.1.9.&nbsp;
Threat: Clickjacking Attack against Authorization</h3>

<p>
              Clickjackingとは, 不正なサイトが不可視iframe (<a class='info' href='#iFrame'>[iFrame]<span> (</span><span class='info'>World Wide Web Consortium, &ldquo;Frames in HTML documents,&rdquo; December&nbsp;1999.</span><span>)</span></a>) に対象サイトをロードし, 対象サイト上の重要なボタンに会うようにその下のレイヤーに偽ボタンを配置し, 被害者のクリックを誘導する攻撃である.
              ユーザーが可視ボタンをクリックすると, 実際には不可視ページ上のボタンがクリックされる. (「認可」ボタンなど)
            
</p>
<p>
              影響: アタッカーはユーザーの認証クレデンシャル (訳注: ID & Passwordなど) やリソースアクセスを得る.
            
</p>
<p>
              対抗策:
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  モダンブラウザでは, X-FRAME-OPTIONSヘッダーを利用して認可フロー中でiframeの利用を禁止することができる.
                  (<a class='info' href='#clickjacking_xframe'>Section&nbsp;5.2.2.6<span> (</span><span class='info'>X-FRAME-OPTIONS Header</span><span>)</span></a>)
                
</li>
<li>
                  レガシーブラウザでは, JavaScript frame-busting (<a class='info' href='#Framebusting'>[Framebusting]<span> (</span><span class='info'>Rydstedt, G., Bursztein, Boneh, D., and C. Jackson, &ldquo;Busting Frame Busting: a Study of Clickjacking           Vulnerabilities on Popular Sites,&rdquo; May&nbsp;2010.</span><span>)</span></a>) が利用できる.
                  ただしこれはすべてのブラウザで動作するとは限らない.
                
</li>
</ul><p>
            
</p>
<a name="anchor36"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.1.10"></a><h3>4.4.1.10.&nbsp;
Threat: Resource Owner Impersonation</h3>

<p>
              クライアントが保護リソースへのアクセスを要求する際, 通常認可フローではリソースオーナーの明示的なアクセス許可/拒否が行われる.
              しかしながら, 不正クライアントが認可フローの詳細を把握し, プログラムによって認可フローに必要なリクエストを実行することも考えられる.
              こうすることにより, クライアントはユーザー同意なしに被害者のリソースへのアクセス権限を得ることができる.
              認可サーバーがユーザーインタラクションを必要としない認証手法を取ったり, 複数ページにまたがる認可フローを分割可能にしていると, このような攻撃に対して脆弱になる.
            
</p>
<p>
              不正クライアントは不可視HTMLユーザーエージェントを利用して認可サーバーが送信するHTMLフォームを中断し, 自動的に同様のHTTP POSTリクエストを実行する.
              なお, このときアタッカーは認可サーバー上でリソースオーナーの認証済セッションを利用できる必要がある.
              これは以下のような手段で実現可能となる.
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  不正クライアントは, 該当デバイス上の外部ブラウザやクロスブラウザクッキーに残っている既存セッションを悪用することができる.
                
</li>
<li>
                  不正クライアントは, まずユーザーに承認できる程度のscopeの認可を要求し, その後ブラウザに残されたセッションをこっそり悪用して他のscopeへのアクセスを得ることができる.
                
</li>
<li>
                  その他に, アタッカーは認可サーバーのユーザーインタラクションを必要としないリソースオーナー認証メカニズムを悪用することもできる. (例: クライアント証明書など)
                
</li>
</ul><p>
              いずれのケースでも, 攻撃は被害者のデバイス上のユーザーエージェント, もしくはネイティブアプリケーションで実行される必要がある.
            
</p>
<p>
              注: この攻撃はCSRF対策では防止できない.
              アタッカーは認可サーバー自身で構築されたnonceなどを含むURLを「実行」しているに過ぎない.
              (訳注: Cookieなどもすべて取られているという仮定であろう)
            
</p>
<p>
              対抗策:
            
</p>
<p>
              認可サーバーは自身のリスク分析に基づき, この脅威を検知および防止すべきかどうか決定すべきである.
            
</p>
<p>
              この攻撃を防ぐため, 認可サーバーは以下のように推測不可能な入力値を伴うユーザーインタラクションを強制することも考えられる.
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  パスワード認証とユーザー同意を単一のフォームにする.
                
</li>
<li>
                  CAPTCHAを用いる.
                
</li>
<li>
                  なんらかの手段でリソースオーナーにOne-timeシークレットを送信し, それを利用させる.
                  (テキストメッセージ, インスタントメッセージなどを利用)
                
</li>
</ul><p>
              その他に, リソースオーナーに不正アクセスを検知させるため, 認可サーバーがアクセス認可が行われた際にリソースオーナーに適切な手段で通知するという方法も考えられる.
              (テキストメッセージ, インスタントメッセージ, emailなどを利用)
            
</p>
<a name="anchor37"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.1.11"></a><h3>4.4.1.11.&nbsp;
Threat: DoS Attacks That Exhaust Resources</h3>

<p>
              認可コードやアクセストークンが十分なエントロピーを持っておらず, ユーザーの関与やユーザーごとの認可コード/トークン数の制限無しに自動的にアクセス許可を行う場合, アタッカーは認可リクエストを繰り返して認可サーバーの認可コード/アクセストークンプールを枯渇させることができる.
            
</p>
<p>
              対抗策:
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  認可サーバーはユーザーごとに発行可能なアクセストークンに上限を設けるべきである.
                
</li>
<li>
                  認可サーバーは認可コードに十分なエントロピーを持たせるべきである.
                
</li>
</ul><p>
            
</p>
<a name="semi"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.1.12"></a><h3>4.4.1.12.&nbsp;
Threat: DoS Using Manufactured Authorization &quot;codes&quot;</h3>

<p>
              ボットネットを持つアタッカーであれば, "http://" で始まるリダイレクトURIを収集し, それらにランダムな認可コードを付与してアクセスすることで, 認可サーバーに大量のHTTPSコネクションを集中させることができる.
              (訳注: クライアントのリダイレクトURIは "http://" であり, 認可サーバーの認可エンドポイントは "https://" である点がポイント)
              これは認可サーバーに対するDoSアタックになりうる.
            
</p>
<p>
              この攻撃は, クライアントがCSRF対策を行ったりstateパラメーターを利用していたとしても可能である. (<a class='info' href='#section_csrf'>Section&nbsp;4.4.1.8<span> (</span><span class='info'>Threat: CSRF Attack against redirect-uri</span><span>)</span></a>)
              CSRF対策が行われている場合, アタッカーは正規のCSRFコードやstateパラメーターを取得するため, 追加のHTTPリクエストを行えばよい.
              追加のHTTPリクエストが必要になることで, アタッカーは2倍のコストを必要とするが, HTTPSとHTTPのコスト比が2倍以上であれば, アタッカーは認可サーバーに対してDoSアタックを成立させることができる.
              (<a class='info' href='#SSL-Latency'>[SSL&#8209;Latency]<span> (</span><span class='info'>Sissel, J., Ed., &ldquo;SSL handshake latency and HTTPS optimizations,&rdquo; June&nbsp;2010.</span><span>)</span></a> によってHTTPS/HTTPのコスト比は約3.5倍となる)
            
</p>
<p>
              影響: 認可コードフローのこの特徴によりアタッカーが得るメリットには以下のようなものがある.
            
</p>
<p>
              </p>
<ol class="text">
<li>
                  Connection Laundering: 正規クライアントが攻撃者と認可サーバーの間に存在するため, 認可サーバーがアタッカーの身元を知るのは困難である.
                  そのためアタッカーのマシンに対するrate limitも困難である.
                  もちろんアタッカーはTorなどの匿名化システムを利用してConnection Launderingを行うこともできるが, その効果は匿名化に用いるシステムによって異なる.
                  一方で, 潜在的に多くのOAuthクライアントがこの攻撃に利用される可能性がある.
                  (訳注: "Connection Laundering" に対する適切な訳語が見つからないが, 「身元を隠して攻撃すること」というニュアンス)
                
</li>
<li>
                  非対称なリソース利用: アタッカーはHTTPコネクションに必要なコストを負担し, HTTPSコネクションに必要なコストを認可サーバーに与えることができる.
                  複数クライアントにまたがったHTTPSコネクションの発生タイミングも, 比較的簡単にコントロールすることができる.
                  もちろんHTTPのWebページに認可サーバーのHTTPS URLをロードすriframeを仕込み, ユーザーをそのWebページに誘導するなどして同様の攻撃を行うこともできるが, その場合攻撃タイミングのコントロールは困難であろう.
                
</li>
</ol><p>
              対抗策:
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  これは完全な対抗策ではないが, クライアントはCSRF対策を行った上で暗号論的擬似乱数生成器により生成されたstateパラメーターを利用すべきである.
                  そしてクライアントはCSRFトークンおよびstateパラメーターの検証が終わってから認可サーバーにアクセスすべきである.
                
</li>
<li>
                  クライアントがシングルサインオンプロトコルやパスワード認証などでユーザーを認証しているのであれば, 不正な認可コードを一定以上入力してきたユーザーのアカウントを一時的に停止すべきである.
                
</li>
<li>
                  認可サーバーは不正な認可コードが送信されたことを示すエラーレスポンスを返し, 一定以上そのようなリクエストを行うクライアントに対してはrate limitやコネクション拒否などの対応を行うべきである.
                
</li>
</ul><p>
            
</p>
<a name="anchor38"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.1.13"></a><h3>4.4.1.13.&nbsp;
Threat: Code Substitution (OAuth Login)</h3>

<p>
              アタッカーは被害者のアイデンティティを用いてアプリケーションやWebサイトにログインすることも考えられる.
              アイデンティティ情報をOAuthにより保護されたサービスのAPIに頼っていると, それが脆弱性につながることがあるのである.
              これは「ソーシャルログイン」と呼ばれるシナリオで散見されるパターンである.
            
</p>
<p>
              前提条件として, リソースサーバーがユーザーのアイデンティティを提供するAPIを持っている必要がある.
              クライアントは, OAuthのアクセストークンを使ってこの「アイデンティティAPI」にアクセスし, そのレスポンスに含まれる識別子を使ってユーザーを識別する.
              クライアントはこの一連の操作を持ってユーザーが認証されたものとして扱う.
            
</p>
<p>
              クライアントが認可コードグラントタイプを利用している場合, アタッカーはクライアントが利用しているのと同じIdentity Provider (IdP) から, ターゲットとなる被害者の認可コードを取得する必要がある.
              このためアタッカーは, 被害者に対して, 同じIdPを通じて悪意あるアプリへログインするよう誘導する.
              (このアプリはIdPにとっては正規クライアントである可能性がある)
              それを受けてIdPはアイデンティティAPIへのアクセス権限を含む認可コードを発行する.
              悪意あるアプリケーションはその認可コードをアタッカーに送り, アタッカーはそれを受けてターゲットとなるクライアントへのログインフローを開始し, 認可レスポンスに含まれる認可コードを被害者のものに置き換える.
              リソースサーバーに関して言えばaudienceは正常であるため, クライアントは受け取った認可コードをアクセストークンと交換し, アイデンティティAPIにアクセスする.
              しかしながらアイデンティティAPIのレスポンスには被害者の識別子が含まれるため, アタッカーはターゲットクライアント上の被害者のアカウントにログインできる.
            
</p>
<p>
              影響: アタッカーは特定のアプリケーションおよびそのアプリケーション内のユーザーデータにアセクセスできる.
            
</p>
<p>
              対抗策:
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  すべてのクライアントは, 認可コードをアクセストークンと交換する際, 必ずクライアントIDを提示しなければならない.
                  認可サーバーはその認可コードがそのクライアントに対して発行されたものかどうかを検証しなければならない.
                  可能であればクライアント認証も行うことが望ましい.
                
</li>
<li>
                  クライアントは認証の為にはOpenID (<a class='info' href='#OPENID'>[OPENID]<span> (</span><span class='info'>, &ldquo;OpenID Foundation Home Page,&rdquo; .</span><span>)</span></a>) やSAML (<a class='info' href='#OASIS.sstc-saml-bindings-1.1'>[OASIS.sstc&#8209;saml&#8209;bindings&#8209;1.1]<span> (</span><span class='info'>Maler, E., Ed., Mishra, P., Ed., and R. Philpott, Ed., &ldquo;Bindings and Profiles for the OASIS Security Assertion Markup           Language (SAML) V1.1,&rdquo; September&nbsp;2003.</span><span>)</span></a>) といったそれに適したプロトコルを利用すべきである.
                  両プロトコルとも, クライアントに関するaudience制約をサポートしている.
                
</li>
</ul><p>
            
</p>
<a name="implicit_flow"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.2"></a><h3>4.4.2.&nbsp;
Implicit Grant</h3>

<p>
            implicitグラントタイプフローでは, アクセストークンがリダイレクトURIのフラグメントを通じて直接クライアントに渡される.
            HTTPユーザーエージェントはHTTPサーバーにフラグメント部分を送らないので, トークンはリダイレクトURIが指し示す対象には送られないと想定される.
            よってクライアント・ユーザーエージェント間の通信経路上でアクセストークンを盗聴したりHTTPリファラーヘッダー経由でトークンが漏洩することはない.
          
</p>
<a name="anchor39"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.2.1"></a><h3>4.4.2.1.&nbsp;
Threat: Access Token Leak in Transport/Endpoints</h3>

<p>
              トークンがアタッカーに盗聴される可能性がある.
              トークンはリダイレクトURIのフラグメントを通じてサーバーからクライアントに渡される.
              この通信がセキュアで無い場合, トークンが漏洩する.
            
</p>
<p>
              影響: アタッカーがトークンの持つ権限を得る.
            
</p>
<p>
              対抗策:
            
</p>
<p>
              </p>
<ul class="text"><a class='info' href='#conf_requests'>Section&nbsp;5.1.1<span> (</span><span class='info'>Ensure Confidentiality of Requests</span><span>)</span></a>
</ul><p>
            
</p>
<a name="anchor40"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.2.2"></a><h3>4.4.2.2.&nbsp;
Threat: Access Token Leak in Browser History</h3>

<p>
              アタッカーはブラウザ履歴からトークンを取得できる.
              これにはアタッカーが特定のデバイスにアクセスできる必要がある.
            
</p>
<p>
              対抗策:
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  トークンの有効期間を短くする. (<a class='info' href='#short_exp_time'>Section&nbsp;5.1.5.3<span> (</span><span class='info'>Use Short Expiration Time</span><span>)</span></a>)
                  トークンのscopeを狭めることも, この攻撃の影響を軽減する可能性がある. (<a class='info' href='#limit_scope'>Section&nbsp;5.1.5.1<span> (</span><span class='info'>Limit Token Scope</span><span>)</span></a>)
                
</li>
<li>
                  レスポンスをキャッシュさせない.
                
</li>
</ul><p>
            
</p>
<a name="mal_client2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.2.3"></a><h3>4.4.2.3.&nbsp;
Threat: Malicious Client Obtains Authorization</h3>

<p>
              不正クライアントが詐欺によりトークンを受け取る.
            
</p>
<p>
              クライアント認証の実施を除いては, <a class='info' href='#mal_client'>Section&nbsp;4.4.1.4<span> (</span><span class='info'>Threat: Malicious Client Obtains Authorization</span><span>)</span></a> と同様の対策が可能である.
            
</p>
<a name="anchor41"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.2.4"></a><h3>4.4.2.4.&nbsp;
Threat: Manipulation of Scripts</h3>

<p>
              アタッカーがクライアントWebサーバーになりすまし, クライアント (のスクリプト) を改竄もしくは置き換える可能性がある.
              これはDNS/ARP Spoofingにより可能になる.
              Webブラウザ上にスクリプト言語で実装されたクライアントが対象となる.
            
</p>
<p>
              影響: アタッカーはユーザーのクレデンシャルを取得し, ユーザーのアイデンティティをも乗っ取り可能であろう.
            
</p>
<p>
              対抗策:
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  認可サーバーはスクリプトを配信するサーバーを認証すべきである.
                  (<a class='info' href='#server_authn'>Section&nbsp;5.1.2<span> (</span><span class='info'>Utilize Server Authentication</span><span>)</span></a>)
                
</li>
<li>
                  クライアントは通信系路上でスクリプトが改竄されていないことを保証すべきである.
                  (<a class='info' href='#conf_requests'>Section&nbsp;5.1.1<span> (</span><span class='info'>Ensure Confidentiality of Requests</span><span>)</span></a>)
                
</li>
<li>
                  ユーザーごとのone-timeシークレット (client_secretなど) を導入し, スクリプトがサーバーからロードされてから短期間だけ, そのスクリプトだけがそのシークレットを利用できるようにすることも考えられる.
                  これにより, アタッカーがクライアントサイドのスクリプトをコピーして改竄時に使い回す場合の効率を下げることができる.
                
</li>
</ul><p>
            
</p>
<a name="anchor42"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.2.5"></a><h3>4.4.2.5.&nbsp;
Threat: CSRF Attack against redirect-uri</h3>

<p>
              CSRF攻撃 (<a class='info' href='#section_csrf'>Section&nbsp;4.4.1.8<span> (</span><span class='info'>Threat: CSRF Attack against redirect-uri</span><span>)</span></a>) はimplicitグラントフロー中のリダイレクトURIに対しても実行可能である.
              アタッカーは, 事前に自身のリソースに対するアクセストークンを取得しておき, そのトークンを含むリダイレクトURIを構築することができる.
              その後ユーザーを騙してそのリダイレクトURIにアクセスさせることに成功した場合, クライアントにはそれを防ぐ手だてはない.
              被害者は, そのクライアントに対して発行されたアタッカーのアクセストークンと, 紐づけられることになるであろう.
            
</p>
<p>
              影響: ユーザーはアタッカーのリソースへのアクセスを行う.
              その影響はリソースの種類によって異なるが, 例えばユーザーがプライベートなデータをアタッカーの管理下のリソースにアップロードしてしまうことなどが考えられる.
              OAuthが3rd-partyログインに使われている場合であれば, IdP上のアタッカーのアカウントとクライアント上の被害者アカウントが紐づけられてしまい, アタッカーが他デバイスからでも簡単にクライアント上の被害者アカウントにログインできてしまうことになる.
            
</p>
<p>
              対抗策:
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  一連の認可リクエストとアクセストークンを含むリダイレクトレスポンスを紐づけるため, stateパラメーターを用いるべきである.
                  クライアント自身が開始した認可リクエストに対応するリダイレクトレスポンス以外は受け付けないようにする.
                  なおstateパラメーターは推測不可能であり, クライアントはその値を秘匿に保つべきである.
                
</li>
<li>
                  クライアント開発者およびエンドユーザーに, 信頼できないURLを踏まないように教育する.
                
</li>
</ul><p>
            
</p>
<a name="anchor43"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.2.6"></a><h3>4.4.2.6.&nbsp;
Threat: Token Substitution (OAuth Login)</h3>

<p>
              アタッカーは被害者のアイデンティティを利用してアプリケーションやWebサイトにログインを試みることがある.
              OAuthで保護されたAPIから取得したアイデンティティデータを使ってユーザー認証を行うアプリケーションが, この脅威の対象となる.
              この攻撃パターンは "social login" と呼ばれるシナリオで見受けられる.
            
</p>
<p>
              前提条件として, リソースサーバーがユーザーの個人情報を取得するためのAPIを提供しており, かつその情報を持ってユーザーのアイデンティティが得られたと見なすことができる必要がある.
              これはつまり, クライアントがリソースサーバーのAPIを "Identity" APIとして扱っているということである.
              クライアントは, OAuthのアクセストークンを使ってアイデンティティAPIにアクセスし, ユーザーのアイデンティティを取得した後, 自身が内部で持つユーザーアカウントデータ (ログイン情報) から該当ユーザーを特定する.
              このフローでユーザーの情報を取得できることを根拠として, クライアントは該当ユーザーが認証されたものとして扱う.
            
</p>
<p>
              この攻撃では, アタッカーは同じIdentity Providerがターゲットのクライアントに向けて発行した, 被害者の正規のアクセストークンを取得する必要がある.
              アタッカーが被害者を騙して, ターゲットクライアントのふりをして不正アプリにログインさせるなどが, その方法となる.
              (この不正アプリはIdentity Providerから見ると, 正規のクライアントのように見える)
              こうすることで, Identity Providerの認可サーバーは該当Identity Provider用のアクセストークンを発行することになる.
              それを受け, 不正アプリは得られたアクセストークンをアタッカーに送信し, それをトリガーとしてアタッカーはターゲットアプリのログインフローを開始する.
              ここでアタッカーは認可レスポンスを改竄し, 自身のアクセストークンの代わりに被害者のアクセストークンをレスポンスに含める.
              このトークンは, リソースサーバーに関しては正規のaudienceを持つため, アイデンティティAPIで受け入れられる.
              しかしアイデンティティAPIから返されるユーザー識別子は被害者のものであるため, アタッカーはターゲットアプリに被害者としてログインできてしまう.
            
</p>
<p>
              影響: アタッカーは, そのアプリケーション自体へのアクセス, および被害者がアプリケーション内で持つユーザーデータへのアクセスを取得することになる.
            
</p>
<p>
              対抗策:
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  クライアントは, OpenID (<a class='info' href='#OPENID'>[OPENID]<span> (</span><span class='info'>, &ldquo;OpenID Foundation Home Page,&rdquo; .</span><span>)</span></a>) や SAML (<a class='info' href='#OASIS.sstc-saml-bindings-1.1'>[OASIS.sstc&#8209;saml&#8209;bindings&#8209;1.1]<span> (</span><span class='info'>Maler, E., Ed., Mishra, P., Ed., and R. Philpott, Ed., &ldquo;Bindings and Profiles for the OASIS Security Assertion Markup           Language (SAML) V1.1,&rdquo; September&nbsp;2003.</span><span>)</span></a>) など, ユーザー認証に適切なプロトコルを利用するべきである.
                  ここであげた2つのプロトコルは, どちらもクライアント上でのaudience制約をサポートする.
                
</li>
</ul><p>
            
</p>
<a name="pwd_flow"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.3"></a><h3>4.4.3.&nbsp;
Resource Owner Password Credentials</h3>

<p>
            リソースオーナーパスワードクレデンシャルグラントタイプ (<a class='info' href='#RFC6749'>[RFC6749]<span> (</span><span class='info'>Hardt, D., &ldquo;The OAuth 2.0 Authorization Framework,&rdquo; October&nbsp;2012.</span><span>)</span></a> Section 4.3) は, レガシーシステムからの移行のためなどにしばしば利用される.
            このグラントタイプでは, クライアントは自身のクレデンシャルの他に, エンドユーザーのIDとパスワードにも直接アクセスし, それらを使ってアクセストークンを取得する.
            このグラントタイプはUID/パスワードアンチパターンに当てはまるため, 他のグラントタイプより高リスクである.
            さらに, 認可プロセスはユーザーのコントロール下にないため, このグラントタイプを利用するクライアントはscopeによる制約を受けず, 潜在的にはユーザー自身と同じ権限を持ちうる.
            (訳注: ID & パスワードを教えた時点でおしまいということ)
            認可ステップが存在しないため, トークンの無効化機能もバイパスされうる.
          
</p>
<p>
            往々にして2つ以上のサービスで同じパスワードを使うというケースが存在するため, このアンチパターンは提供されたクレデンシャルにアクセス可能ないかなるサービスをもリスクにさらす可能性がある.
            さらに, 容易に同じ主体であると推測できる情報 (joe@example.com と joe@example.net のペアなど) から, 同じパスワードが違う場所で利用されていることを容易に推測可能なケースもありうる.
          
</p>
<p>
            影響: リソースサーバーは, 特定のクライアントに紐づけられたアクセストークンベースでしかscopeの区別を付けることができない.
            クライアントは長期間有効なトークンを取得しアタッカーにそれを送信することもできる.
            クライアントおよびエンドポイントにいる主体は, ユーザーIDとパスワードを盗聴可能である.
          
</p>
<p>
            対抗策:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                移行のため以外の目的でこのグラントタイプを利用するのはなるべく避ける.
              
</li>
<li>
                認可サーバーはトークンリフレッシュ時に毎回リフレッシュトークンに紐づくクライアントIDを検証すべきである.
                (<a class='info' href='#binding_refresh_client_id'>Section&nbsp;5.2.2.2<span> (</span><span class='info'>Binding of Refresh Token to &quot;client_id&quot;</span><span>)</span></a>)
              
</li>
<li>
                OAuth Core仕様にあるように, 認可サーバーはTLSのようなトランスポートレイヤーのメカニズムによって通信が保護されていることを保証しなければならない.
                (<a class='info' href='#conf_requests'>Section&nbsp;5.1.1<span> (</span><span class='info'>Ensure Confidentiality of Requests</span><span>)</span></a>)
              
</li>
<li>
                各サービスは, ユーザーに複数のサービスで同じパスワードを使うことの危険性を教えるべきである.
              
</li>
<li>
                リソースオーナーパスワードクレデンシャルグラントの利用を, 同じ組織が運営するクライアントアプリケーションに限定する.
              
</li>
</ul><p>
          
</p>
<a name="anchor44"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.3.1"></a><h3>4.4.3.1.&nbsp;
Threat: Accidental Exposure of Passwords at Client Site</h3>

<p>
              クライアントのセキュリティが不十分な場合, アタッカーや内部犯行者がユーザーのパスワードを取得する可能性がある.
            
</p>
<p>
              対抗策:
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  クライアントがリソースオーナークレデンシャルにアクセスすることのない, 他のフローを利用する.
                
</li>
<li>
                  平文でクレデンシャルを扱うのではなく, ダイジェスト認証を利用する.
                
</li>
<li>
                  ログに含まれるアクセストークンを解読困難にする.
                
</li>
</ul><p>
            
</p>
<a name="anchor45"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.3.2"></a><h3>4.4.3.2.&nbsp;
Threat: Client Obtains Scopes without End-User Authorization</h3>

<p>
              すべてのリソースオーナーとのインタラクションは, クライアントによって行われるため, 意図の有無にかかわらず, リソースオーナーが認識しないもしくは意図していなかったscopeを持つトークンが発行される可能性がある.
              例えば, リソースオーナーが, クライアントはメディアストレージへのread-onlyアクセスのみを必要としていると思ったにも関わらず, クライアントは実際にはフルアクセス権限をリクエストしていた, というようなこともありうる.
            
</p>
<p>
              対抗策:
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  クライアントがリソースオーナークレデンシャルにアクセスすることのない, 他のフローを利用する.
                
</li>
<li>
                  認可サーバーはこのフローで発行されたアクセストークンのscopeを制限することができる.
                  (<a class='info' href='#limit_scope'>Section&nbsp;5.1.5.1<span> (</span><span class='info'>Limit Token Scope</span><span>)</span></a>)
                  もし特定のクライアントが信頼でき, かつセキュアに認証可能な場合は, そのような制約を設けないこともある.
                  リソースオーナーが事前に (設定画面などで) このフローで取得できるscopeの上限を設定することも検討可能である.
                
</li>
<li>
                  認可サーバーは適切な経路 (emailなど) でリソースオーナーにグラント発行通知を送ることもできる.
                  (<a class='info' href='#informed'>Section&nbsp;5.1.3<span> (</span><span class='info'>Always Keep the Resource Owner Informed</span><span>)</span></a>)
                
</li>
</ul><p>
            
</p>
<a name="anchor46"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.3.3"></a><h3>4.4.3.3.&nbsp;
Threat: Client Obtains Refresh Token through Automatic Authorization</h3>

<p>
              すべてのリソースオーナーとのインタラクションは, クライアントによって行われるため, 意図の有無にかかわらず, リソースオーナーの意思に反してクライアントが長期間有効なリフレッシュトークンを取得する可能性がある.
            
</p>
<p>
              対抗策:
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  クライアントがリソースオーナークレデンシャルにアクセスすることのない, 他のフローを利用する.
                
</li>
<li>
                  認可サーバーはこのフローではリフレッシュトークンの発行を禁止することもできる.
                  (<a class='info' href='#restricted_refresh'>Section&nbsp;5.2.2.1<span> (</span><span class='info'>Restricted Issuance of Refresh Tokens</span><span>)</span></a>)
                  もし特定のクライアントが信頼でき, かつセキュアに認証可能な場合は, そのような制約を設けないこともある.
                  リソースオーナーに (設定画面などで) このフローでのリフレッシュトークンの発行を禁止させることも検討可能である.
                
</li>
<li>
                  認可サーバーは適切な経路 (emailなど) でリソースオーナーにグラント発行通知を送ることもできる.
                  (<a class='info' href='#informed'>Section&nbsp;5.1.3<span> (</span><span class='info'>Always Keep the Resource Owner Informed</span><span>)</span></a>)
                
</li>
</ul><p>
            
</p>
<a name="anchor47"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.3.4"></a><h3>4.4.3.4.&nbsp;
Threat: Obtaining User Passwords on Transport</h3>

<p>
              アタッカーが通信を盗聴してユーザーのパスワードを盗むことも考えられる.
            
</p>
<p>
              影響: 1人のエンドユーザーのパスワード漏洩
            
</p>
<p>
              対抗策:
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  リクエストの秘匿性を保証する.
                  (<a class='info' href='#conf_requests'>Section&nbsp;5.1.1<span> (</span><span class='info'>Ensure Confidentiality of Requests</span><span>)</span></a>)
                
</li>
<li>
                  平文でクレデンシャルを送信することのない認証手段を用いる.
                  (HMACなど)
                
</li>
</ul><p>
            
</p>
<a name="anchor48"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.3.5"></a><h3>4.4.3.5.&nbsp;
Threat: Obtaining User Passwords from Authorization Server Database</h3>

<p>
              データベースへの不正アクセスやSQLインジェクション攻撃などにより, アタッカーが認可サーバーのデータベースから有効なユーザー名とパスワードのペアを盗み出すことも考えられる.
            
</p>
<p>
              影響: 全ユーザーのユーザー名 & パスワードペアの漏洩.
              これは, 同じクレデンシャルを他サービスで利用しているケースなどでは, 認可サーバーのドメインを超えて影響を与える.
            
</p>
<p>
              対抗策:
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  クレデンシャルストレージ保護のためのベストプラクティスに従う.
                  (<a class='info' href='#cred_storage_prot'>Section&nbsp;5.1.4.1<span> (</span><span class='info'>Enforce Credential Storage Protection Best Practices</span><span>)</span></a>)
                
</li>
</ul><p>
            
</p>
<a name="anchor49"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.3.6"></a><h3>4.4.3.6.&nbsp;
Threat: Online Guessing</h3>

<p>
              アタッカーが正規のユーザー名 & パスワードペアを推測し, passwordグラントとして利用することも考えられる.
            
</p>
<p>
              影響: 1人のユーザー名 & パスワードペアの漏洩.
            
</p>
<p>
              対抗策:
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  セキュアパスワードポリシーに従う.
                  (<a class='info' href='#pwd_policy'>Section&nbsp;5.1.4.2.1<span> (</span><span class='info'>Utilize Secure Password Policy</span><span>)</span></a>)
                
</li>
<li>
                  アカウントロック. (<a class='info' href='#lock_accounts'>Section&nbsp;5.1.4.2.3<span> (</span><span class='info'>Lock Accounts</span><span>)</span></a>)
                
</li>
<li>
                  tar pitを利用する. (<a class='info' href='#tar_pit'>Section&nbsp;5.1.4.2.4<span> (</span><span class='info'>Use Tar Pit</span><span>)</span></a>)
                
</li>
<li>
                  CAPTCHAを利用する. (<a class='info' href='#captchas'>Section&nbsp;5.1.4.2.5<span> (</span><span class='info'>Use CAPTCHAs</span><span>)</span></a>)
                
</li>
<li>
                  passwordグラントを利用しない.
                
</li>
<li>
                  クライアント認証という他の認証要素によって, 攻撃を邪魔することもある.
                  (<a class='info' href='#client_aa'>Section&nbsp;5.2.3<span> (</span><span class='info'>Client Authentication and Authorization</span><span>)</span></a>)
                
</li>
</ul><p>
            
</p>
<a name="anchor50"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.4"></a><h3>4.4.4.&nbsp;
Client Credentials</h3>

<p>
            クライアントクレデンシャル (<a class='info' href='#RFC6749'>[RFC6749]<span> (</span><span class='info'>Hardt, D., &ldquo;The OAuth 2.0 Authorization Framework,&rdquo; October&nbsp;2012.</span><span>)</span></a> Section 3) は, クライアント認証のための手段 (client secretのマッチングなど) と紐づいた識別子 (secretではない) により構成される.
            このグラントタイプに対する脅威は, <a class='info' href='#pwd_flow'>Section&nbsp;4.4.3<span> (</span><span class='info'>Resource Owner Password Credentials</span><span>)</span></a> で述べられたものと類似している.
          
</p>
<a name="anchor51"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.5"></a><h3>4.5.&nbsp;
Refreshing an Access Token</h3>

<a name="anchor52"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.5.1"></a><h3>4.5.1.&nbsp;
Threat: Eavesdropping Refresh Tokens from Authorization Server</h3>

<p>
            アタッカーが認可サーバー・クライアント間の通信を盗聴しリフレッシュトークンを盗み出す可能性がある.
          
</p>
<p>
            対抗策:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                OAuth Core仕様にあるように, 認可サーバーは通信がTLSのようなトランスポートレイヤーメカニズムによって保護されていることを保証しなければならない.
                (<a class='info' href='#conf_requests'>Section&nbsp;5.1.1<span> (</span><span class='info'>Ensure Confidentiality of Requests</span><span>)</span></a>)
              
</li>
<li>
                もしend-to-endの機密性が確保できない場合は, 発行するアクセストークンのscopeを狭め有効期限を短くすることで, 漏洩時のリスクを軽減できる.
                (<a class='info' href='#limit_scope'>Section&nbsp;5.1.5.1<span> (</span><span class='info'>Limit Token Scope</span><span>)</span></a>, <a class='info' href='#short_exp_time'>Section&nbsp;5.1.5.3<span> (</span><span class='info'>Use Short Expiration Time</span><span>)</span></a>)
              
</li>
</ul><p>
          
</p>
<a name="anchor53"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.5.2"></a><h3>4.5.2.&nbsp;
Threat: Obtaining Refresh Token from Authorization Server Database</h3>

<p>
            この脅威は, 認可サーバーがリフレッシュトークンをhandleとしてデータベースに保存している場合に起こりうる.
            アタッカーはデータベースへのアクセス権を不正取得したり, SQLインジェクション攻撃によって, 認可サーバーのデータベースからリフレッシュトークンを取得する可能性がある.
          
</p>
<p>
            影響: 全リフレッシュトークンの漏洩.
          
</p>
<p>
            対抗策:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                クレデンシャルストレージのベストプラクティスに従う.
                (<a class='info' href='#cred_storage_prot'>Section&nbsp;5.1.4.1<span> (</span><span class='info'>Enforce Credential Storage Protection Best Practices</span><span>)</span></a>)
              
</li>
<li>
                アタッカーがクライアントIDとシークレットを盗めないことが想定できる場合は, トークンをクライアントIDと紐付ける.
                (<a class='info' href='#bind_token_client_id'>Section&nbsp;5.1.5.8<span> (</span><span class='info'>Bind Token to Client id</span><span>)</span></a>)
              
</li>
</ul><p>
          
</p>
<a name="anchor54"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.5.3"></a><h3>4.5.3.&nbsp;
Threat: Obtaining Refresh Token by Online Guessing</h3>

<p>
            アタッカーが有効なリフレッシュトークンの値を推測し, それをrefresh_tokenグラントとして用いてアクセストークンを取得する可能性がある.
          
</p>
<p>
            影響: 単一のリフレッシュトークンおよびそれを使って取得できるアクセストークンの漏洩.
          
</p>
<p>
            対抗策:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                handleベースデザインの場合はこちら. (<a class='info' href='#high_entropy'>Section&nbsp;5.1.4.2.2<span> (</span><span class='info'>Use High Entropy for Secrets</span><span>)</span></a>)
              
</li>
<li>
                assertionベースデザインの場合はこちら. (<a class='info' href='#signed_tokens'>Section&nbsp;5.1.5.9<span> (</span><span class='info'>Sign Self-Contained Tokens</span><span>)</span></a>)
              
</li>
<li>
                トークンをクライアントIDと紐づける.
                これによりアタッカーはトークンと紐づいたクライアントIDをも推測しなければならなくなる.
                (<a class='info' href='#bind_token_client_id'>Section&nbsp;5.1.5.8<span> (</span><span class='info'>Bind Token to Client id</span><span>)</span></a>)
              
</li>
<li>
                クライアント認証を行う.
                これによりさらにアタッカーの推測項目が増える.
                (<a class='info' href='#depl_specific_secretes'>Section&nbsp;5.2.3.4<span> (</span><span class='info'>Issue Installation-Specific Client Secrets</span><span>)</span></a>)
              
</li>
</ul><p>
          
</p>
<a name="anchor55"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.5.4"></a><h3>4.5.4.&nbsp;
Threat: Refresh Token Phishing by Counterfeit Authorization Server</h3>

<p>
            アタッカーが認可サーバーへのリクエストをプロキシし, 有効なリフレッシュトークンを取得しようとする可能性がある.
            認可サーバーURLはクライアント開発時で既知であるか, 少なくとも既知のリソースサーバーから取得できる状態にあることが想定されるため, アタッカーは攻撃のためある程度のスプーフィングを必要とする.
          
</p>
<p>
            対抗策:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                サーバー認証. (<a class='info' href='#server_authn'>Section&nbsp;5.1.2<span> (</span><span class='info'>Utilize Server Authentication</span><span>)</span></a>)
              
</li>
</ul><p>
          
</p>
<a name="anchor56"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.6"></a><h3>4.6.&nbsp;
Accessing Protected Resources</h3>

<a name="anchor57"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.6.1"></a><h3>4.6.1.&nbsp;
Threat: Eavesdropping Access Tokens on Transport</h3>

<p>
            アタッカーがクライアント・リソースサーバー間の通信系路上で有効なアクセストークンを取得する可能性がある.
            アクセストークンは認可サーバーとリソースサーバーの間で共有されるシークレット情報であるため, 他のクレデンシャル (エンドユーザーパスワードなど) と同じような保護が必要である.
          
</p>
<p>
            対抗策:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                Bearerトークンとして送信されるアクセストークンは, セキュアでないチャネルで平文で送るべきではない.
                OAuth Core仕様にあるように, アクセストークン送信時はTLSなどのトランスポートメカニズムによって通信を保護しなければならない.
                (<a class='info' href='#conf_requests'>Section&nbsp;5.1.1<span> (</span><span class='info'>Ensure Confidentiality of Requests</span><span>)</span></a>)
              
</li>
<li>
                トークンの有効期限を短くすることで, 漏洩時のリスクを軽減できる.
                (<a class='info' href='#short_exp_time'>Section&nbsp;5.1.5.3<span> (</span><span class='info'>Use Short Expiration Time</span><span>)</span></a>)
              
</li>
<li>
                アクセストークンをクライアント識別子と紐付け, クライアントにリソースサーバーに対してその所有権を証明させる.
                (<a class='info' href='#authn_requests'>Section&nbsp;5.4.2<span> (</span><span class='info'>Authenticated Requests</span><span>)</span></a>)
              
</li>
</ul><p>
          
</p>
<a name="anchor58"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.6.2"></a><h3>4.6.2.&nbsp;
Threat: Replay of Authorized Resource Server Requests</h3>

<p>
            アタッカーがユーザーデータを取得/改変/破壊するため, 有効なリクエストをリプレイする可能性がある.
          
</p>
<p>
            対抗策:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                リソースサーバーはTLSのようなトランスポートレイヤーメカニズムを用いて, この攻撃を防ぐべきである.
                (<a class='info' href='#conf_requests'>Section&nbsp;5.1.1<span> (</span><span class='info'>Ensure Confidentiality of Requests</span><span>)</span></a>)
                これによりアタッカーは正規のリクエストをキャプチャできなくなる.
              
</li>
<li>
                代替策として, リソースサーバーは署名付きリクエスト (<a class='info' href='#signed_requests'>Section&nbsp;5.4.3<span> (</span><span class='info'>Signed Requests</span><span>)</span></a>) をnonceとtimestampと共に利用し, 各リクエストをユニークに識別することができる.
                リソースサーバーはこの情報によりリプレイを検知し, リクエストを拒否すべきである.
              
</li>
</ul><p>
          
</p>
<a name="anchor59"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.6.3"></a><h3>4.6.3.&nbsp;
Threat: Guessing Access Tokens</h3>

<p>
            トークンがhandleの場合, アタッカーは他のアクセストークンから得られる情報を頼りにアクセストークンの値を推測する可能性がある.
          
</p>
<p>
            影響: 単一ユーザーのデータにアクセスされる.
          
</p>
<p>
            対抗策:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                handleトークンには十分なエントロピーを持たせ, 有効な値の推測を不可能にするべきである.
                (<a class='info' href='#high_entropy'>Section&nbsp;5.1.4.2.2<span> (</span><span class='info'>Use High Entropy for Secrets</span><span>)</span></a>)
              
</li>
<li>
                assertion (もしくはself-contained) トークンの内容は, 電子署名により保護すべきである.
                (<a class='info' href='#signed_tokens'>Section&nbsp;5.1.5.9<span> (</span><span class='info'>Sign Self-Contained Tokens</span><span>)</span></a>)
              
</li>
<li>
                アクセストークン有効期限の短縮は, さらにいっそうセキュリティを強化する.
                (<a class='info' href='#exp_time'>5.1.5.2<span> (</span><span class='info'>Determine Expiration Time</span><span>)</span></a> & <a class='info' href='#short_exp_time'>5.1.5.3<span> (</span><span class='info'>Use Short Expiration Time</span><span>)</span></a>)
              
</li>
</ul><p>
          
</p>
<a name="anchor60"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.6.4"></a><h3>4.6.4.&nbsp;
Threat: Access Token Phishing by Counterfeit Resource Server</h3>

<p>
            アタッカーが特定のリソースサーバーを装って, 特定の認可サーバーから発行されたアクセストークンを受け取る可能性がある.
            クライアントが有効なアクセストークンをこの偽リソースサーバーに送ると, サーバーはリソースオーナーの認可のもと他のサービスにアクセスできるようになる.
          
</p>
<p>
            対抗策:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                クライアントは, セキュアチャネルの有無に関わらず, 未知のリソースサーバーに対して認証済みリクエストを送るべきでない.
                リソースサーバーURLがクライアントに対して既知な場合は, セキュアチャネルを利用することでリソースサーバーの認証が可能である.
                (<a class='info' href='#server_authn'>Section&nbsp;5.1.2<span> (</span><span class='info'>Utilize Server Authentication</span><span>)</span></a>)
              
</li>
<li>
                クライアントがアクセスするリソースサーバーのエンドポイントURLを, アクセストークンと関連づけ, 正規のリソースサーバーではその関連を検証する.
                (audienceフィールドなどを利用)
                エンドポイントURLのバリデーションポリシーは, 厳密な完全一致でもよいし, ホストのみの一致などのラフな方法でもよい.
                この手法では, 認可サーバーがリソースサーバーエンドポイントURLを認可プロセス中に知る必要がある.
              
</li>
<li>
                アクセストークンをクライアントと関連づけ, リソースサーバーへのリクエスト時にクライアントを認証する.
                (典型的には, 潜在的アタッカーにシークレットを漏らさないため, 署名を利用する)
                これにより, 偽サーバーはリソースサーバーに対して正しく認証を行うことができなくなると想定できるので, 攻撃を防ぐことができる.
                (<a class='info' href='#authn_requests'>Section&nbsp;5.4.2<span> (</span><span class='info'>Authenticated Requests</span><span>)</span></a>)
              
</li>
<li>
                トークンのscopeを狭めたり, トークンの有効範囲を特定のリソースサーバーに限定するなど.
                ( <a class='info' href='#limit_scope'>Section&nbsp;5.1.5.1<span> (</span><span class='info'>Limit Token Scope</span><span>)</span></a>, <a class='info' href='#bind_token_rs'>Section&nbsp;5.1.5.5<span> (</span><span class='info'>Bind Tokens to a Particular Resource Server (Audience)</span><span>)</span></a>)
              
</li>
</ul><p>
          
</p>
<a name="anchor61"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.6.5"></a><h3>4.6.5.&nbsp;
Threat: Abuse of Token by Legitimate Resource Server or Client</h3>

<p>
            正規のリソースサーバーが別のリソースサーバーにアクセスしようとする可能性がある.
            同じように, クライアントもまた取得したトークンを別のリソースサーバーに対して使うこともありうる.
          
</p>
<p>
            対抗策:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                トークン有効範囲を特定のリソースサーバーに限定するべきである.
                (<a class='info' href='#bind_token_rs'>Section&nbsp;5.1.5.5<span> (</span><span class='info'>Bind Tokens to a Particular Resource Server (Audience)</span><span>)</span></a>)
              
</li>
</ul><p>
          
</p>
<a name="anchor62"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.6.6"></a><h3>4.6.6.&nbsp;
Threat: Leak of Confidential Data in HTTP Proxies</h3>

<p>
            <a class='info' href='#RFC6749'>[RFC6749]<span> (</span><span class='info'>Hardt, D., &ldquo;The OAuth 2.0 Authorization Framework,&rdquo; October&nbsp;2012.</span><span>)</span></a> にあるOAuth HTTP認証スキームはオプショナルである.
            しかしながら, <a class='info' href='#RFC2616'>[RFC2616]<span> (</span><span class='info'>Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, &ldquo;Hypertext Transfer Protocol -- HTTP/1.1,&rdquo; June&nbsp;1999.</span><span>)</span></a> は認証コンテキストの識別のため Authorization および WWW&#8209;Authenticate ヘッダーに依存し, それによってセキュリティを担保している.
            特にプロキシやキャッシュなどにより, これらのヘッダーを利用しないリクエストが適切に保護されないケースがありうる.
            例えば, プライベートな認証コンテキストがパブリックにアクセス可能な状態でキャッシュされるといったことが考えられる.
          
</p>
<p>
            対抗策:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                OAuth HTTP認証スキーム (<a class='info' href='#authz_header'>Section&nbsp;5.4.1<span> (</span><span class='info'>Authorization Headers</span><span>)</span></a>) を利用しないクライアントやリソースサーバーは, Cache-Controlヘッダーを使って上記のリスクを最小化すべきである.
                上記のようなクライアントは, Cache&#8209;Control ヘッダーに "no-store" <a class='info' href='#RFC2616'>[RFC2616]<span> (</span><span class='info'>Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, &ldquo;Hypertext Transfer Protocol -- HTTP/1.1,&rdquo; June&nbsp;1999.</span><span>)</span></a> をセットすべきである.
                また上記のようなリソースサーバーは, サクセスレスポンス (2xxステータス) の Cache-Control ヘッダーに "private" <a class='info' href='#RFC2616'>[RFC2616]<span> (</span><span class='info'>Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, &ldquo;Hypertext Transfer Protocol -- HTTP/1.1,&rdquo; June&nbsp;1999.</span><span>)</span></a>をセットすべきである.
              
</li>
<li>
                アクセストークンのscopeと有効期限を制限し, 漏洩時のリスクを軽減する.
                (<a class='info' href='#limit_scope'>Section&nbsp;5.1.5.1<span> (</span><span class='info'>Limit Token Scope</span><span>)</span></a>, <a class='info' href='#short_exp_time'>Section&nbsp;5.1.5.3<span> (</span><span class='info'>Use Short Expiration Time</span><span>)</span></a>)
              
</li>
</ul><p>
          
</p>
<a name="anchor63"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.6.7"></a><h3>4.6.7.&nbsp;
Threat: Token Leakage via Log Files and HTTP Referrers</h3>

<p>
            アクセストークンがURIクエリーパラメータとして送られる場合, トークンがログファイルやHTTPリファラーなどを通じて漏洩する可能性がある.
          
</p>
<p>
            対抗策:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                URI リクエストパラメーターの代わりに Authorization ヘッダーや POST パラメーターを使う.
                (<a class='info' href='#authz_header'>Section&nbsp;5.4.1<span> (</span><span class='info'>Authorization Headers</span><span>)</span></a>)
              
</li>
<li>
                ログ設定を適切に行う.
              
</li>
<li>
                ログファイルへのアクセスを適切にコントロールする.
                (<a class='info' href='#std_sys'>Section&nbsp;5.1.4.1.1<span> (</span><span class='info'>Enforce Standard System Security Means</span><span>)</span></a>)
              
</li>
<li>
                漏洩したトークンの利用を防止するため, 認証リクエストを強制することも可能である.
                (<a class='info' href='#authn_requests'>Section&nbsp;5.4.2<span> (</span><span class='info'>Authenticated Requests</span><span>)</span></a>)
              
</li>
<li>
                scopeや有効期間を制限することで, 漏洩リスクを軽減する.
                one-timeトークンを利用するのもよい.
                (<a class='info' href='#limit_scope'>Section&nbsp;5.1.5.1<span> (</span><span class='info'>Limit Token Scope</span><span>)</span></a>, <a class='info' href='#short_exp_time'>Section&nbsp;5.1.5.3<span> (</span><span class='info'>Use Short Expiration Time</span><span>)</span></a>, <a class='info' href='#one_time_usage'>Section&nbsp;5.1.5.4<span> (</span><span class='info'>Limit Number of Usages or One-Time Usage</span><span>)</span></a>)
              
</li>
</ul><p>
          
</p>
<a name="security_considerations"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Security Considerations</h3>

<p>
        本セクションでは <a class='info' href='#threat_model'>Section&nbsp;4<span> (</span><span class='info'>Threat Model</span><span>)</span></a> で述べた脅威を軽減するために推奨する対抗策について述べる.
      
</p>
<a name="anchor64"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
General</h3>

<p>
          本セクションでは, すべてのOAuthコンポーネント (クライアント, リソースサーバー, トークンサーバーおよびユーザーエージェント) に対し, 一般に適用可能な対策について考慮する.
        
</p>
<a name="conf_requests"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.1"></a><h3>5.1.1.&nbsp;
Ensure Confidentiality of Requests</h3>

<p>
            これはクライアントから認可サーバーまたはリソースサーバーへ送信されるすべてのリクエスト対し適用可能である.
            OAuthはリクエストの完全性検証のための方式を提供するが, リクエストの秘匿性を保つための方式は提供しない.
            さらなる予防措置を行わない限り, 盗聴者はリクエストの中身にフルアクセスし, シークレットやトークンなどのリクエストの中身を用いて遮断やリプレイアタックを開始することが可能となる.
          
</p>
<p>
            TLS <a class='info' href='#RFC5246'>[RFC5246]<span> (</span><span class='info'>Dierks, T. and E. Rescorla, &ldquo;The Transport Layer Security (TLS) Protocol Version 1.2,&rdquo; August&nbsp;2008.</span><span>)</span></a> のようなトランスポート層でのセキュリティ機構を用いることによって攻撃を軽減することが可能である.
            IPsec VPN <a class='info' href='#RFC4301'>[RFC4301]<span> (</span><span class='info'>Kent, S. and K. Seo, &ldquo;Security Architecture for the Internet Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a> のような仮想プライベートネットワーク (VPN) も同様に考慮に値する.
            (訳注: 「transport-layer mechanisms such as TLS」は, 文脈から「transport-layer "security" mechanisms such as TLS」と見なした. )
          
</p>
<p>
            注: 当文書では各々のプロトコルエンティティ間のコネクションがend-to-endのTLSで保護されていることを想定している.
            データセンターの境界などのようにTLSをオフロードすることによってこの想定から外れているデプロイは, これによって引き起こされる新たな (主に内部者による) 脅威に対処するために, この脅威モデルを改良しなければならない.
          
</p>
<p>
            これは以下の脅威に対する対抗策である:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                トークンエンドポイントやリソースサーバーのエンドポイントとの通信路上で得られたアクセストークンのリプレイ
              
</li>
<li>
                トークンエンドポイントとの通信路上で得られたリフレッシュトークンのリプレイ
              
</li>
<li>
                トークンエンドポイントとの通信路上 (もしくはリダイレクト経路上) で得られた認可コードのリプレイ
                (訳注: 原文末尾の「(redirect?)」はクライアントのリダイレクトエンドポイント (redirection endpoint) との通信路上を示していると解釈)
              
</li>
<li>
                ユーザーパスワードとクライアントシークレットのリプレイ
              
</li>
</ul><p>
            (訳注: アクセストークンと認可コードは, 認可エンドポイントとの通信路上も流れるが, 上記で触れらていないのは記述の漏れの可能性あり)
          
</p>
<a name="server_authn"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.2"></a><h3>5.1.2.&nbsp;
Utilize Server Authentication</h3>

<p>
            HTTPSサーバー認証や類似の手段によってサーバーのアイデンティティを認証することが可能である.
            その目的は, 接続の確立の際にサーバーの完全修飾ドメイン名とサーバーから提示された公開鍵とを確実に結びつけることである.
            (<a class='info' href='#RFC2818'>[RFC2818]<span> (</span><span class='info'>Rescorla, E., &ldquo;HTTP Over TLS,&rdquo; May&nbsp;2000.</span><span>)</span></a> 参照)
          
</p>
<p>
            クライアントはサーバーとそのドメイン名の結びつきを検証すべきである.
            その結びつきの証明に失敗した場合, その通信はman-in-the-middle攻撃を受けていると考えられる.
            このセキュリティ手法は, この目的においてクライアントが信頼している認証局 (CA) に依存している.
            クライアントはこれらの信頼するCAを慎重に選択すべきであり, 信頼するCAの証明書を格納するストレージを変更されないように保護すべきである.
          
</p>
<p>これは以下の脅威に対する対抗策である:
</p>
<p>
            </p>
<ul class="text">
<li>なりすまし (Spoofing)
</li>
<li>通信への不正介在 (Proxying)
</li>
<li>偽のサーバーによるフィッシング
</li>
</ul><p>
          
</p>
<a name="informed"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.3"></a><h3>5.1.3.&nbsp;
Always Keep the Resource Owner Informed</h3>

<p>
            リソースオーナーへの透明性は, OAuthプロトコルの鍵となる要素である.
            ユーザーは常に認可処理の指令者であるべきであり, 判断に必要な情報を得られるべきである.
            さらにいえばユーザーの関与はよりよいセキュリティ対抗策である.
            ユーザーは恐らくある種の攻撃に対して, 認可サーバーよりも正しく認識することができる.
            認可プロセス時, 認可プロセス後, そしてユーザーが情報を得たいと思った時のいずれも, 下記のような手法を用いて情報の提示と交換を行うことができる:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                ユーザ同意のフォーム.
              
</li>
<li>
                通知メッセージ (例えば, Eメール, SMS, &hellip;).
                通知はフィッシング攻撃の経路にもなりうることに注意.
                通知メッセージは, アタッカーによく似たフィッシングメッセージを送信されないよう, 考慮すべきである.
              
</li>
<li>
                アクティビティ/イベントログ.
              
</li>
<li>
                ユーザーが自身でセキュリティ対策を行えるようなアプリケーションあるいはポータル.
              
</li>
</ul><p>
          
</p>
<a name="anchor65"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.4"></a><h3>5.1.4.&nbsp;
Credentials</h3>

<p>
            当セクションでは未認可のアクセスや悪用からあらゆる種類のクレデンシャルを保護するための対抗策について述べる.
            クレデンシャルは, あらゆる種類のトークン (リフレッシュトークンやアクセストークン) や認可コード, あるいはクライアントシークレットやユーザーパスワードのような, 長寿命のシークレットである.
          
</p>
<a name="cred_storage_prot"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.4.1"></a><h3>5.1.4.1.&nbsp;
Enforce Credential Storage Protection Best Practices</h3>

<p>
              管理者はクレデンシャルのストレージ保護に関する業界のベストプラクティスを採用すべきである
              (例えば, <a class='info' href='#OWASP'>[OWASP]<span> (</span><span class='info'>, &ldquo;Open Web Application Security Project Home Page,&rdquo; .</span><span>)</span></a> 参照).
              このようなプラクティスは以下のサブセクションの事項に限定されるものではない.
            
</p>
<a name="std_sys"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.4.1.1"></a><h3>5.1.4.1.1.&nbsp;
Enforce Standard System Security Means</h3>

<p>
                攻撃者がセンシティブな設定ファイルやデータベースにアクセスできないように, サーバーシステムはロックダウン (権限によりアクセス制限) されていることがある.
              
</p>
<a name="std_sql"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.4.1.2"></a><h3>5.1.4.1.2.&nbsp;
Enforce Standard SQL Injection Countermeasures</h3>

<p>
                クライアント識別子やその他の認証コンポーネントをSQLデータベースに対し問い合わせたり比較する場合, 受け取ったパラメータを送信する前に検証しなければインジェクション攻撃を受ける可能性がある.
              
</p>
<p></p>
<ul class="text">
<li>
                    攻撃経路を減らすため, サーバーコードで利用するデータベース特権が最小限になっていることを確認すること.
                  
</li>
<li>
                    入力文字を結合した動的なSQLを避けること.
                    可能であれば静的なSQLを使うこと.
                  
</li>
<li>
                    動的SQLを使う際は, バインド引数によりクエリをパラメータ化すること.
                  
</li>
<li>
                    入力はフィルタリングとサニタイジングを行うこと.
                    例えば, 識別子が既知の書式の時, 提供された値が識別子の構文にマッチしているかを確認すること.
                  
</li>
</ul>

<a name="noclear"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.4.1.3"></a><h3>5.1.4.1.3.&nbsp;
No Cleartext Storage of Credentials</h3>

<p>
                認可サーバーはクリアテキストでクレデンシャルを格納すべきではない.
                典型的なアプローチは代わりにハッシュを格納するか, クレデンシャルを暗号化することである.
                (ユーザーパスワードであるため) クレデンシャルが十分なエントロピーレベルを持っていない場合, オフライン辞書攻撃を困難にするためのソルトを追加することによってストレージが強固になる.
              
</p>
<p>
                注: いくつかの認証プロトコルは, 認可サーバがクリアテキストのシークレットにアクセスできる必要がある.
                サーバがハッシュにしかアクセスできない場合, これらのプロトコルを実装することができない.
                このようなケースの場合, クレデンシャルを強固に暗号化するべきである.
              
</p>
<a name="anchor66"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.4.1.4"></a><h3>5.1.4.1.4.&nbsp;
Encryption of Credentials</h3>

<p>
                クライアントアプリケーションがクライアントクレデンシャルを安全に永続化していない場合, 攻撃者による取得のターゲットとなりやすい.
                キーストアやデータベースのような暗号化永続機構を用いてクライアントクレデンシャルを格納すること.
                クライアントクレデンシャルを直接クライアントコードに記述するとスキャニングに対し脆弱になる.
                またクライアントクレデンシャルの変更の管理が困難にもなる.
              
</p>
<a name="anchor67"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.4.1.5"></a><h3>5.1.4.1.5.&nbsp;
Use of Asymmetric Cryptography</h3>

<p>
                非対称暗号を用いれば, 認可サーバでクレデンシャル管理を行う必要はなくなる.
              
</p>
<a name="online_secrets"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.4.2"></a><h3>5.1.4.2.&nbsp;
Online Attacks on Secrets</h3>

<a name="pwd_policy"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.4.2.1"></a><h3>5.1.4.2.1.&nbsp;
Utilize Secure Password Policy</h3>

<p>
                オンラインパスワード攻撃を困難にすることに繋がるユーザーパスワードのエントロピー増加のため, 認可サーバーは複雑なユーザーパスワードポリシーを強制することもある.
                複雑にしすぎた場合, ユーザーはパスワードを再利用したり, 紙にメモしたり, 安全でない方法で格納したりする可能性があることに注意すること.
              
</p>
<a name="high_entropy"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.4.2.2"></a><h3>5.1.4.2.2.&nbsp;
Use High Entropy for Secrets</h3>

<p>
                人間によって利用されるのではないシークレット (例: クライアントシークレットやトークンハンドル) を生成するとき, 推測攻撃のリスクを軽減するために, 認可サーバーは合理的なレベルのエントロピーを含むように生成すべきである.
                認可サーバーは, 128ビット以上の暗号論的に強固な乱数または擬似乱数シーケンスからトークンの値を生成するべきである.
                (本ドキュメント執筆時点のベストプラクティスとして <a class='info' href='#RFC4086'>[RFC4086]<span> (</span><span class='info'>Eastlake, D., Schiller, J., and S. Crocker, &ldquo;Randomness Requirements for Security,&rdquo; June&nbsp;2005.</span><span>)</span></a> を参照)
              
</p>
<a name="lock_accounts"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.4.2.3"></a><h3>5.1.4.2.3.&nbsp;
Lock Accounts</h3>

<p>
                ある一定の回数試行に失敗した場合, そのアカウントをロックすることにより, パスワードに対するオンライン攻撃を軽減することができる.
              
</p>
<p>
                注: この手法は正規のサービスユーザーのロックダウンに悪用される可能がある.
              
</p>
<a name="tar_pit"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.4.2.4"></a><h3>5.1.4.2.4.&nbsp;
Use Tar Pit</h3>

<p>
                ユーザー名/パスワードによる認証の試行失敗に対して, 認可サーバーはそのアカウントをロックしたり, ある一定の時間, レスポンスを遅延させることがある.
                この時間は, 試行失敗の回数に応じて, 増加することもある.
                この目的は, あるユーザー名に対する攻撃者の試行をスローダウンさせることにある.
              
</p>
<p>
                注: これは認可サーバーのより複雑でステートフルな設計が必要となるかもしれない.
              
</p>
<a name="captchas"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.4.2.5"></a><h3>5.1.4.2.5.&nbsp;
Use CAPTCHAs</h3>

<p>
                人間の対話が必要になることにより, このアイデアはプログラムが大規模な数のパスワードの自動チェックを行うことを防ぐ.
              
</p>
<p>
                注: これは, ユーザーエクスペリエンスにネガティブなインパクトを与える.
              
</p>
<a name="anchor68"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.5"></a><h3>5.1.5.&nbsp;
Tokens (Access, Refresh, Code)</h3>

<a name="limit_scope"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.5.1"></a><h3>5.1.5.1.&nbsp;
Limit Token Scope</h3>

<p>
              認可サーバーはトークンに関連付けられたスコープの縮小または制限を決定することもある.
              この決定の基準は当文書のスコープ外である.
              以下は例である:
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  クライアント固有のポリシー.
                  例えば, パブリッククライアントにはより小さな権限のトークンのみ発行するなど.
                
</li>
<li>
                  サーバー固有のポリシー.
                  例えば, とてもセンシティブなサービスなど.
                
</li>
<li>
                  リソースオーナー固有の設定.
                
</li>
<li>
                  または, これらのポリシーや設定の組み合わせ.
                
</li>
</ul><p>
              認可サーバーはグラントタイプに応じて, 異なるスコープを許可することもある.
              例えば, エンドユーザーと認可サーバーが直接対話することで得た認可 (つまり認可コードグラントタイプ) は, クライアントが「ユーザー名」/「パスワード」を認可サーバーに直接送信することで得た認可 (つまりリソースオーナーパスワードクレンデンシャルグラントタイプ) よりも信頼できるとみなすこともある.
              この手法は以下の脅威の影響を減らすことができる:
            
</p>
<p></p>
<ul class="text">
<li>
                  トークン漏洩
                
</li>
<li>
                  悪意のあるソフトウェアへのトークン発行
                
</li>
<li>
                  リソースオーナークレデンシャルフローで意図していない強い権限のトークンの発行
                
</li>
</ul><p>
            
</p>
<a name="exp_time"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.5.2"></a><h3>5.1.5.2.&nbsp;
Determine Expiration Time</h3>

<p>
              トークンは一般に適切な期間の経過後, 有効期限切れとなるべきである.
              これにより, (署名のような) 他のセキュリティ手法の補完や強化を行うことができ, あらゆる種類のトークン漏洩の影響を減らすことができる.
              トークン漏洩のリスクに応じて, (例えば決済トランザクションに対しては) 数分で有効期限切れとなり, (例えば連絡先情報への読み取りアクセスに対しては) 何時間も有効のままとなる.
            
</p>
<p>
              有効期間は下記のような様々な要因により決定される:
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  トークン漏洩のリスクの大きさ
                
</li>
<li>
                  基本的なアクセスを許可する期間
                
</li>
<li>
                  アクセス許可の変更が有効になるまでの期間
                  (訳注: assertionベースのトークンを用いた場合など, ユーザーが認可サーバー上でアクセス無効化を行ってもクライアントの持つアクセストークンが即座に無効化されない場合がある)
                
</li>
<li>
                  攻撃者が有効なトークンを推測または生成するまでの所要時間
                
</li>
</ul><p>
            
</p>
<a name="short_exp_time"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.5.3"></a><h3>5.1.5.3.&nbsp;
Use Short Expiration Time</h3>

<p>
              短い有効期間のトークンは以下の脅威に対する対策となる:
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  リプレイ
                
</li>
<li>
                  トークン漏洩 (短い有効期間は影響を減らす)
                
</li>
<li>
                  オンライン推測 (短い有効期間は成功の可能性を減らす)
                
</li>
</ul><p>
              注: トークンの有効期間を短くする場合, 認可サーバーとリソースサーバー間のより正確な時刻同期が要求される.
              さらにいえば, 短い有効期間はより多くの (アクセストークンの) トークンリフレッシュを必要とするかもしれないし, エンドユーザによる (認可コードとリフレッシュトークンの) 認可処理の繰り返しに繋がるかもしれない.
            
</p>
<a name="one_time_usage"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.5.4"></a><h3>5.1.5.4.&nbsp;
Limit Number of Usages or One-Time Usage</h3>

<p>
              認可サーバーはトークンの利用回数を制限してもよい.
              これにより以下の脅威を軽減することができる:
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  トークンのリプレイ
                
</li>
<li>
                  推測
                
</li>
</ul><p>
              例えば, 認可サーバーがある認可コードの交換の試行を複数回観測した場合, 現在のリクエストだけでなく, その認可コードに関連づいた全てのアクセストークンを無効化することもありうる.
            
</p>
<p>
              認可コードと同様に, アクセストークンも操作回数に制限があってもよい.
              これは, クライアントアプリケーションを再認証し, 新たなアクセストークンを取得するためにリフレッシュトークンを使用することを強制するか, ユーザーも関与させてアクセストークンの再認可をクライアントに強制することになる.
            
</p>
<a name="bind_token_rs"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.5.5"></a><h3>5.1.5.5.&nbsp;
Bind Tokens to a Particular Resource Server (Audience)</h3>

<p>
              マルチサービス環境にある認可サーバーは, 送信先として意図しているサーバーを明示的にトークン内に指定するなど, 異なるリソースサーバーに対して異なる内容のトークンを発行してもよい.
              SAMLアサーション (<a class='info' href='#OASIS.saml-core-2.0-os'>[OASIS.saml&#8209;core&#8209;2.0&#8209;os]<span> (</span><span class='info'>Cantor, S., Ed., Kemp, J., Ed., Philpott, R., Ed., and E. Maler, Ed., &ldquo;Assertions and Protocols for the OASIS Security Assertion Markup Language (SAML) V2.0,&rdquo; March&nbsp;2005.</span><span>)</span></a> 参照) は, この目的のために Audience 要素を用いている.
              この対抗策は以下の状況に対して使用される:
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  このトークンは一つのリソースサーバーにのみ適用できるため, リプレイ試行の成功の影響を減らす.
                
</li>
<li>
                  このトークンは指定されたリソースサーバーやクライアントでのみ利用できるため, 悪意のあるリソースサーバーやクライアントが自身宛のトークンを他のサーバーに対して悪用することを防ぐ.
                  それを行っても他のサーバによって拒絶される.
                  (訳注: 具体的な被害例はこちらを http://oauth.jp/oauth-20-implicit-flow)
                
</li>
<li>
                  偽のリソースサーバーに対する有効なトークンの漏洩の影響を減らす.
                
</li>
</ul>

<a name="endpoint_audience"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.5.6"></a><h3>5.1.5.6.&nbsp;
Use Endpoint Address as Token Audience</h3>

<p>
              トークン取得時にaudienceとしてエンドポイントURLを指定することで, リソースサーバーを指定することもできる.
              このトークンはリソースサーバー自身のエンドポイントURLを含むため, リソースサーバーは他のリソースサーバーからの不正アクセスを検知することができる.
              (訳注: 複数のリソースサーバーが1つの認可サーバーに認可を委ねており, かつリソースサーバー同士の間に信頼関係が構築できないケースに有効)
            
</p>
<a name="audience_token_scope"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.5.7"></a><h3>5.1.5.7.&nbsp;
Use Explicitly Defined Scopes for Audience and Tokens</h3>

<p>
              実装者は, 各scopeに特定のリソースサーバーに対するアクセス権限を表現させ, 各トークンが明示的にそれらのscopeを持つように設計することもできる.
              (訳注: 暗黙的なdefault scopeを許可しないということ)
              このアプローチは, リソースサーバーやクライアントが想定外の目的でトークンを利用するという攻撃を軽減することができる.
            
</p>
<a name="bind_token_client_id"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.5.8"></a><h3>5.1.5.8.&nbsp;
Bind Token to Client id</h3>

<p>
              認可サーバーはトークンを特定のクライアント識別子に結びつけることもできる.
              この識別子はトークン付きの全てのリクエストに対し検証されるべきである.
              この手法は以下の目的で利用できる:
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  トークン漏洩の検出
                
</li>
<li>
                  トークン悪用の防止
                
</li>
</ul><p>
              注: クライアント識別子の検証は, ターゲットサーバーにクライアントの識別子を認証することを要求することもある.
              この認証は, (例えば, 認可サーバー上に事前登録されたクライアント識別子とシークレットのような) トークンとは独立して管理されたシークレットを利用するか,
              あるいは (例えば, 暗号化されたトークンの中身の一部として) トークン自身と共に送ることで可能となる.
            
</p>
<a name="signed_tokens"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.5.9"></a><h3>5.1.5.9.&nbsp;
Sign Self-Contained Tokens</h3>

<p>
              改竄や偽のトークンの生成を検出するために, 自己完結型トークンは (例えば, ハッシュベースメッセージ認証コードやデジタル署名を用いて) 署名されるべきである.
            
</p>
<a name="enc_token"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.5.10"></a><h3>5.1.5.10.&nbsp;
Encrypt Token Content</h3>

<p>
              自己完結型トークンは, 秘匿性やシステムの内部データを保護するために暗号化されるかもしれない.
              トークンの書式に従い, (例えば共通鍵のような) 鍵がサーバノード間で流通されなければならないかもしれない.
              トークンや暗号化の方法といった流通の方法を定義すべきである.
            
</p>
<a name="assertion_format"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.5.11"></a><h3>5.1.5.11.&nbsp;
Adopt a Standard Assertion Format</h3>

<p>
              アサーションベースのトークンデザインを実装しようするサービス提供者は, 標準のアサーションフォーマットを採用することを強く推奨する (例えば, SAML <a class='info' href='#OASIS.saml-core-2.0-os'>[OASIS.saml&#8209;core&#8209;2.0&#8209;os]<span> (</span><span class='info'>Cantor, S., Ed., Kemp, J., Ed., Philpott, R., Ed., and E. Maler, Ed., &ldquo;Assertions and Protocols for the OASIS Security Assertion Markup Language (SAML) V2.0,&rdquo; March&nbsp;2005.</span><span>)</span></a>や, JavaScript Object Notation Web Token (JWT) <a class='info' href='#OAuth-JWT'>[OAuth&#8209;JWT]<span> (</span><span class='info'>Jones, M., Bradley, J., and N. Sakimura, &ldquo;JSON Web Token (JWT),&rdquo; December&nbsp;2012.</span><span>)</span></a>のような).
            
</p>
<a name="access_tokens"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.6"></a><h3>5.1.6.&nbsp;
Access Tokens</h3>

<p>
            アクセストークンを保護するために以下の手法が使われるべきである:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                (クライアントアプリケーションからのみアクセス可能な) 一時的なメモリに保持すること.
              
</li>
<li>
                安全なトランスポート (TLS) を用いて安全にトークンを受け渡すこと.
              
</li>
<li>
                クライアントアプリケーションはサードパーティーとトークンを共有しないことを確認すること.
              
</li>
</ul>

<a name="anchor69"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Authorization Server</h3>

<p>
          当セクションではOAuth認可サーバのエンドポイントに関する注意点について述べる.
        
</p>
<a name="anchor70"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.1"></a><h3>5.2.1.&nbsp;
Authorization &quot;codes&quot;</h3>

<a name="automatic_code_revocation"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.1.1"></a><h3>5.2.1.1.&nbsp;
Automatic Revocation of Derived Tokens If Abuse Is Detected</h3>

<p>
              認可サーバーが (例えば, 認可コードのような) 認可グラント交換リクエストを複数回検知した場合, その認可グラントに関連づいた全てのトークンを無効化することもありうる.
            
</p>
<a name="refresh_tokens"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.2"></a><h3>5.2.2.&nbsp;
Refresh Tokens</h3>

<a name="restricted_refresh"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.2.1"></a><h3>5.2.2.1.&nbsp;
Restricted Issuance of Refresh Tokens</h3>

<p>
              認可サーバーは, 適切なポリシーに基づいて, リフレッシュトークンを発行しないと決断することもありうる.
              リフレッシュトークンは長期間有効なクレデンシャルのため, 窃取される可能性が高いかもしれない.
              例えば, 認可サーバはこのようなトークンを安全に格納できないと考えられるクライアントに対し, リフレッシュトークンの発行を拒否することもありうる.
            
</p>
<a name="binding_refresh_client_id"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.2.2"></a><h3>5.2.2.2.&nbsp;
Binding of Refresh Token to &quot;client_id&quot;</h3>

<p>
              認可サーバーは全てのリフレッシュトークンについて, 意図している発行先のクライアントの識別子とマッチしているかの確認処理をすべきである.
              認可サーバーは同じ "client_id" がアクセストークンのリフレッシュ要求の全てに存在することをチェックすべきである.
              (例えばコンフィデンシャルクライアントのように) 可能な場合, 認可サーバーは各リクエストにおいてクライアントを認証すべきである.
            
</p>
<p>
              これはリフレッシュトークンの窃取や漏洩に対する対抗策である.
            
</p>
<p>
              注: このリフレッシュトークンと "client_id" の対応は認可なしに変更されないように保護されるべきである.
            
</p>
<a name="refresh_replace"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.2.3"></a><h3>5.2.2.3.&nbsp;
Refresh Token Rotation</h3>

<p>
              リフレッシュトークンローテーションは, 異なるアプリケーションやデバイスから同時に同じリフレッシュトークンが利用されることを自動的に検出し阻止することを意図している.
              この事態はクライアントからトークンが盗まれ, それを攻撃者と正当なクライアントの両方が用いた場合に発生する.
              基本的な考えは, 古いリフレッシュトークンを用いたアクセストークン取得の試行を検出するために, 全てのリフレッシュリクエストの度にリフレッシュトークンの値を変更することである.
              認可サーバーは攻撃者と正当なクライアントのどちらがアクセスしようとしているのか判断できないため, 古いリフレッシュトークンを用いたアクセス試行があった場合, 有効なリフレッシュトークンとこれに関連したアクセス認可の両方を無効化する.
            
</p>
<p>
              OAuth仕様は, グラントタイプが "refresh_token" のときでも, 認可サーバーが新たなリフレッシュトークンをトークンレスポンスとして返すのを可能とすることでこの方法をサポートしている.
            
</p>
<p>
              注: この方法は, 現在有効なリフレッシュトークンの使用状況を確認しなければならないため, クラスター環境では問題を引き起こす可能性がある.
              このような環境では, 他の方法の方がより適切であるかもしれない.
            
</p>
<a name="refresh_revocation"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.2.4"></a><h3>5.2.2.4.&nbsp;
Revocation of Refresh Tokens</h3>

<p>
              認可サーバーは, クライアントまたはエンドユーザーによるリフレッシュトークン無効化の明示的なリクエストを許可してもよい.
              トークンの無効化方法は <a class='info' href='#OAuth-REVOCATION'>[OAuth&#8209;REVOCATION]<span> (</span><span class='info'>Lodderstedt, T., Ed., Dronia, S., and M. Scurtescu, &ldquo;Token Revocation,&rdquo; November&nbsp;2012.</span><span>)</span></a> で仕様化されている.
            
</p>
<p>
              これは以下に対する対抗策となる:
            
</p>
<p></p>
<ul class="text">
<li>
                  デバイスの盗難
                
</li>
<li>
                  リソースオーナーのなりすまし
                
</li>
<li>
                  信用できなくなったクライアントアプリケーション
                
</li>
</ul>

<a name="device_id"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.2.5"></a><h3>5.2.2.5.&nbsp;
Device Identification</h3>

<p>
              認可サーバーは認証クレデンシャルとデバイス識別子の紐付けを要求してもよい.
              International Mobile Station Equipment Identity <a class='info' href='#IMEI'>[IMEI]<span> (</span><span class='info'>3GPP, &ldquo;International Mobile station Equipment Identities           (IMEI),&rdquo; September&nbsp;2012.</span><span>)</span></a> はこのような識別子の一例である. またOS固有の識別子も存在する.
              特定のデバイスからトークンが窃取されたことを検出するために, 認可サーバーはユーザークレデンシャルの認証時にこのような識別子を含めることができる.
            
</p>
<p>
              注: いかなる実装においてもデバイス識別子を用いることのプライバシーへの影響の可能性を考慮すべきである.
            
</p>
<a name="clickjacking_xframe"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.2.6"></a><h3>5.2.2.6.&nbsp;
X-FRAME-OPTIONS Header</h3>

<p>
              X-FRAME-OPTIONS ヘッダー (<a class='info' href='#X-Frame-Options'>[X&#8209;Frame&#8209;Options]<span> (</span><span class='info'>Ross, D. and T. Gondrom, &ldquo;HTTP Header X-Frame-Options,&rdquo; October&nbsp;2012.</span><span>)</span></a> 参照) をサーバーサイドから指定することによって, iframeでの表示を回避することを最近のブラウザに対しては強制することができる.
              このヘッダーは "DENY" と "SAMEORIGIN" という2種類の値を持つことができ, フレーム表示を一切禁止することと, 異なるオリジンのサイトでは禁止することをそれぞれ意味する.
              "ALLOW-FROM" という値を指定することができるブラウザも存在し, この場合は, iframeでの表示を許可する信頼できるオリジンのリストも併せて指定する.
            
</p>
<p>
              これは以下の脅威に対する対抗策である:
            
</p>
<p>
              </p>
<ul class="text">
<li>クリックジャッキング攻撃
</li>
</ul><p>
            
</p>
<a name="client_aa"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.3"></a><h3>5.2.3.&nbsp;
Client Authentication and Authorization</h3>

<p>
            <a class='info' href='#sec_features'>Section&nbsp;3<span> (</span><span class='info'>Security Features</span><span>)</span></a> (Security Features) で述べたように, クライアントは以下のような様々な目的で識別, 認証, 認可される.
          
</p>
<p>
            </p>
<ul class="text">
<li>
                一連のリクエストが同じクライアントで実行されているか照合する.
              
</li>
<li>
                認可サーバーによってクライアントが認識されていることをユーザーに示す.
              
</li>
<li>
                認可サーバーやリソースサーバー上の機能へのクライアントのアクセスを認可する.
              
</li>
<li>
                分析や統計のためにクライアント識別子をログファイルに記録する.
              
</li>
</ul><p>
            クライアントタイプ毎に機能や特性が異なるため, 上記の目的を達成する方法も複数ある.
            これらの方法について当セクションで述べる.
            認可サーバー提供者はセキュリティポリシーとクライアントのデプロイについて注意し, それに従って適切に取り扱うべきである.
            例えば一つの例として, 全てのクライアントは信頼できず安全ではないとみなして取り扱うといったようなことが挙げられるだろう.
            その対極として, サービス提供者は全てのクライアントのインストールを管理者が個々に有効化することによって, ソフトウェアパッケージのアイデンティティに対する信頼性と, このクライアントがインストールされた環境のセキュリティを確保するといった例が挙げられる.
            これら2つの例の間の中間的なアプローチもいくつも考えられる.
          
</p>
<a name="dont_issue"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.3.1"></a><h3>5.2.3.1.&nbsp;
Don't Issue Secrets to Clients with Inappropriate Security Policy</h3>

<p>
              認可サーバーはシークレットを保護できないクライアント (パブリッククライアント) に対してシークレットを発行すべきではない.
              これはクライアントが強固に認証されたと認可サーバーが取り扱ってしまう可能性を減らす.
            
</p>
<p>
              例えば, あるネイティブアプリケーションの全てのインストールで共有される単一のクライアント識別子とシークレットを生成することは, あまりよくない.
              このようなシナリオでは, アプリケーションマーケットのような配布チャネルを通じて, 開発者からそのアプリケーションを利用する全てのエンドユーザのデバイスに対してシークレットを伝えなければならない.
              アプリケーションのソースコードや関連のリソースバンドルに埋め込まれたシークレットは, リバースエンジニアリングに対しては無力である.
              次に, このようなシークレットを無効化すると, そのアプリケーションの全てのインストールが即座に動作しなくなってしまうため, 無効化することができない.
              さらに, 認可サーバーはクライアント識別子を実際には信用できないため, そのクライアントの信頼性をエンドユーザに示すことは危険だろう.
            
</p>
<p>
              以下のセクションで述べるように, 妥当なセキュリティレベルを達成する他の方法がある:
            
</p>
<a name="forced_user_consent"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.3.2"></a><h3>5.2.3.2.&nbsp;
Require User Consent for Public Clients without Secret</h3>

<p>
              認可サーバーはパブリッククライアントに対し自動認可を許すべきではない.
              認可サーバーは個々のクライアント識別子を発行するかもしれないが, 全ての認可処理はエンドユーザーによる承認を必要とすべきである.
              シークレットなしのクライアントは, 以下の脅威に対する対抗策である:
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  パブリッククライアントアプリケーションのなりすまし.
                
</li>
</ul>

<a name="client_id_redirect"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.3.3"></a><h3>5.2.3.3.&nbsp;
Issue a &quot;client_id&quot; Only in Combination with &quot;redirect_uri&quot;</h3>

<p>
              認可サーバーは "client_id" の発行と共に, その "client_id" に対し事前設定されたクライアント個別の "redirect_uri" を関連付けるかもしれない.
              そして, 異なるリダイレクトURIを持つ認可リクエストを受けた場合は自動的に拒否する.
              もしくは, 認可サーバーは認可リクエストにどのようなリダイレクトURIが設定されていたとしてもそれを無視し, 代わりに既知の事前設定されたリダイレクトURIに対して常にリダイレクトすべきである.
              これはシークレットを持たないクライアントにおける以下の脅威に対する対抗策である:
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  クロスサイトスクリプティング攻撃
                
</li>
<li>
                  パブリッククライアントアプリケーションのなりすまし
                
</li>
</ul>

<a name="depl_specific_secretes"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.3.4"></a><h3>5.2.3.4.&nbsp;
Issue Installation-Specific Client Secrets</h3>

<p>
              認可サーバーは, ある一つのクライアント (つまりソフトウェアパッケージ) について, インストール毎に異なるクライアント識別子とシークレットを発行するかもしれない.
              このようなアプローチは, "public" クライアントを "confidential" クライアントに変える効果があるだろう.
            
</p>
<p>
              ウェブアプリケーションにとっては, これは一つの "client_id" とソフトウェアパッケージがインストールされているウェブサイト毎に異なる一つの "client_id" と "client_secret" のペアを作ることを意味するだろう.
              そして, その個々のサイトの提供者はウェブサイトのセットアップの際に, 認可サーバーにクライアント識別子とシークレットを要求することになるだろう.
              これは, そのウェブサイトのリダイレクトURIやウェブサイトURL, その他の有用な属性の検証を可能とするだろう.
              このウェブサイトの提供者はそのサイト上でのクライアントシークレットのセキュリティを確保しなければならない.
            
</p>
<p>
              ネイティブアプリケーションにとっては, あるアプリケーションの様々なデバイス上における全てのコピーは異なるインストールであるため, より複雑である.
              このシナリオではインストール固有のシークレットとして, 以下のどちらかのパターンで "client_id" と "client_secret" を取得する必要が出てくる:
            
</p>
<p>
              </p>
<ol class="text">
<li>
                  アプリケーションマーケットからのダウンロードプロセス中
                
</li>
<li>
                  デバイスへのインストール中
                
</li>
</ol><p>
              いずれのアプローチもクライアント識別子とシークレットを発行するための自動機構が必要となるであろうが, OAuthでは現状その機構を定義していない.
            
</p>
<p>
              一つ目のアプローチはアプリケーションの真正性に対するある程度の信頼が確保できるが, 二つ目のオプションはクライアントの属性の検証ではなくインストールの真正性のみが確保される.
              しかしこれは少なくとも, 様々なリプレイ攻撃を防止する助けになるだろう.
              さらに, インストール固有のクライアント識別子とシークレットは, 特定のインストールに対する全てのリフレッシュトークンの選択的な無効化を一度で行うことを可能とする.
            
</p>
<a name="val_redirect"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.3.5"></a><h3>5.2.3.5.&nbsp;
Validate Pre-Registered &quot;redirect_uri&quot;</h3>

<p>
              認可サーバーは全てのクライアントに "redirect_uri" を登録することを要求すべきであり, その "redirect_uri" は <a class='info' href='#RFC6749'>[RFC6749]<span> (</span><span class='info'>Hardt, D., &ldquo;The OAuth 2.0 Authorization Framework,&rdquo; October&nbsp;2012.</span><span>)</span></a> で定義された完全なURIであるべきである.
              この登録の方法については当ドキュメントの対象外である.
              OAuthのコア仕様のとおり, エンドユーザー認可エンドポイントへそれぞれの "client_id" と共に送信されるリダイレクトURIは, 登録されているリダイレクトURIと合致していなければならない.
              それが合致していなかった場合, 認可サーバーはその受信したGETリクエストは攻撃者によって送信されたものとみなし, 拒絶するべきである.
              注: 認可サーバーはこのような認可リクエストのリダイレクトURIにユーザーエージェントをリダイレクトすべきではない.
              事前登録された "redirect_uri" を検証することは, 以下の脅威に対する対抗策となる:
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  偽のウェブサイトへの認可コードの漏洩:
                  これは, エンドユーザーが最初に認可エンドポイントにリダイレクトされてきた際に認可サーバーによって攻撃の試行の検出を可能とする.
                  (<a class='info' href='#authz_code_leakage'>Section&nbsp;4.4.1.7<span> (</span><span class='info'>Threat: Authorization &quot;code&quot; Leakage through Counterfeit Client</span><span>)</span></a>)
                
</li>
<li>
                  クライアントのリダイレクトエンドポイントを通じたオープンリダイレクタ攻撃.
                  (<a class='info' href='#open_redirector_client'>Section&nbsp;4.1.5<span> (</span><span class='info'>Threat: Open Redirectors on Client</span><span>)</span></a>)
                
</li>
<li>
                  認可サーバーのリダイレクトエンドポイントを通じたオープンリダイレクタフィッシング攻撃.
                  (<a class='info' href='#open_redirector'>Section&nbsp;4.2.4<span> (</span><span class='info'>Threat: Open Redirector</span><span>)</span></a>)
                
</li>
</ul><p>
              この手法の根底にある想定は, 認可コードを取得するには攻撃者がその他のリダイレクトURIを使用する必要が出てくることである.
              実装者は, 攻撃者がこのセキュリティ手法を回避するために被害者のデバイスに対してなりすまし攻撃を行う可能性を検討するかもしれない.
            
</p>
<p>
              注: クライアントの事前登録は (手動で処理する) デプロイではスケールしないかもしれない.
              または (まだ仕様化されていない) 動的クライアント登録を必要とするかもしれない.
              動的クライアント登録がない場合, 事前登録された "redirect_uri" は開発・設定時のデプロイに紐づけられたクライアントでのみ有効に動作する.
              即時の動的なリソースサーバーのディスカバリーが必要な場合は, この事前登録 "redirect_uri" ではもはや実現可能ではないかもしれない.
            
</p>
<a name="client_secret_revocation"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.3.6"></a><h3>5.2.3.6.&nbsp;
Revoke Client Secrets</h3>

<p>
              認可サーバーは漏洩したシークレットの悪用を防止するため, クライアントのシークレットを無効化するかもしれない.
            
</p>
<p>
              注: この手段では, 対象のクライアントに発行された認可コードやリフレッシュトークンも即時にすべて無効化するだろう.
              これは対象のネイティブアプリケーションやウェブアプリケーションの複数のデプロイで使用されているクライアント識別子やシークレットに意図しない影響を与えるかもしれない.
            
</p>
<p>
              これは以下に対する対抗策である
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  プライベートクライアントの漏洩したクライアントシークレットの悪用
                
</li>
</ul><p>
            
</p>
<a name="strong_client_authn"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.3.7"></a><h3>5.2.3.7.&nbsp;
Use Strong Client Authentication (e.g., client_assertion/client_token)</h3>

<p>
              クライアントアサーション <a class='info' href='#OAuth-ASSERTIONS'>[OAuth&#8209;ASSERTIONS]<span> (</span><span class='info'>Campbell, B., Mortimore, C., Jones, M., and Y. Goland, &ldquo;Assertion Framework for OAuth 2.0,&rdquo; December&nbsp;2012.</span><span>)</span></a> のような代替の認証方式を使用することによって, "client_secret" の流通が不要となる.
              これは, 安全な秘密鍵ストアや認証プロセス中にクライアントアサーションの発行者によって指定されたその他の追加の認証システムの使用が必要となるかもしれない.
            
</p>
<a name="anchor71"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.4"></a><h3>5.2.4.&nbsp;
End-User Authorization</h3>

<p>
            当セクションではエンドユーザーの関与する認可フローに関する注意点について述べる.
          
</p>
<a name="automatic_processing"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.4.1"></a><h3>5.2.4.1.&nbsp;
Automatic Processing of Repeated Authorizations Requires Client Validation</h3>

<p>
              クライアントがクライアントシークレットによる認証や, または署名された認証アサーション証明書 (<a class='info' href='#strong_client_authn'>Section&nbsp;5.2.3.7<span> (</span><span class='info'>Use Strong Client Authentication (e.g., client_assertion/client_token)</span><span>)</span></a>) や事前登録されたリダイレクトURIの検証 (<a class='info' href='#val_redirect'>Section&nbsp;5.2.3.5<span> (</span><span class='info'>Validate Pre-Registered &quot;redirect_uri&quot;</span><span>)</span></a>) のようなその他の認証メカニズムによる認証を受けていないとき, 認可サーバーは繰り返しの認可を自動処理すべきではない.
            
</p>
<a name="informed_decisions"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.4.2"></a><h3>5.2.4.2.&nbsp;
Informed Decisions Based on Transparency</h3>

<p>
              認可サーバーはエンドユーザーに認可プロセスで何が起き, 結果がどうなるかを明確に説明すべきである.
              例えば, ユーザーはどのようなアクセス権をどのくらいの期間クライアントに与えようとしているかを理解すべきである.
              またサーバーがそのクライアントの属性 (ウェブサイトURLやセキュリティポリシー) について確実に証明できるかどうかをユーザーに明らかにすべきである.
            
</p>
<a name="validation_end_user"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.4.3"></a><h3>5.2.4.3.&nbsp;
Validation of Client Properties by End User</h3>

<p>
              認可のプロセスでは, ユーザーは典型的にはクライアントからの認可のリクエストの承認を求められる.
              認可サーバーによって認識されているクライアントの名前とユーザーが利用しているウェブサイトやアプリケーションの名前が適合しているかどうかなど, クライアントの属性の検証にエンドユーザーが関与できるため, これは重要なセキュリティメカニズムである.
              この手法は特に認可サーバーがクライアントを認証できない状況のときに有用である.
              これは以下に対する対抗策である:
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  悪意のあるアプリケーション
                
</li>
<li>
                  他のクライアントに成り済ますクライアントアプリケーション
                
</li>
</ul>

<a name="bind_code_client_id"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.4.4"></a><h3>5.2.4.4.&nbsp;
Binding of Authorization &quot;code&quot; to &quot;client_id&quot;</h3>

<p>
              認可サーバーは全ての認可コードをエンドユーザー認可プロセスを開始したクライアントの識別子と紐づけるべきである.
              この手法は以下に対する対抗策である.
            
</p>
<p></p>
<ul class="text">
<li>
                  異なるクライアントクレデンシャルを用いた認可コードのリプレイ.
                  なぜなら攻撃者は認可コードをトークンに交換するために他の "client_id" を使用することができないため.
                
</li>
<li>
                  認可コードのオンライン推測
                
</li>
</ul><p>
              注: この紐づけは認可なしに変更されないように保護されるべきである
              (例えば, 保護メモリ および／または セキュアデータベースを使用する).
            
</p>
<a name="bind_code_redirect"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.4.5"></a><h3>5.2.4.5.&nbsp;
Binding of Authorization &quot;code&quot; to &quot;redirect_uri&quot;</h3>

<p>
              認可サーバーは全ての認可コードをエンドユーザー認可プロセスでクライアントへのリダイレクトの宛先として使用される実際のリダイレクトURIと紐づけできるようにすべきである.
              この紐づけは, クライアントが認可コードをアクセストークンに交換しようとした際に, 検証されるべきである.
             攻撃者が認可コードをアクセストークンに交換する際に別のリダイレクトURIを使用することができないため, この方法は偽のウェブサイトへの認可コードの漏洩に対する対抗策となる.
            
</p>
<a name="anchor72"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
Client App Security</h3>

<p>
          当セクションはクライアントアプリケーションに対するSecurity Considerationsを扱う.
        
</p>
<a name="cred_software"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.1"></a><h3>5.3.1.&nbsp;
Don't Store Credentials in Code or Resources Bundled with Software Packages</h3>

<p>
            クライアントソフトウェアのコピーは多数作られるため, アプリケーションの全てのインストールで共有される単一のクライアント識別子とシークレットを生成することは, あまりよくない.
            クライアントシークレットが安全に保持されるとは言えないため, このようなアプリケーションはパブリッククライアントと見なされるだろう.
            アプリケーションのソースコードや関連のリソースバンドルに埋め込まれたシークレットは, リバースエンジニアリングに対しては無力である.
            次に, このようなシークレットを無効化すると, そのアプリケーションの全てのインストールが即座に動作しなくなってしまうため, 無効化することができない.
            さらに, 認可サーバーはクライアント識別子を実際には信用できないため, そのクライアントの信頼性をエンドユーザに示すことは危険だろう.
          
</p>
<a name="std_web"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.2"></a><h3>5.3.2.&nbsp;
Use Standard Web Server Protection Measures (for Config Files and Databases)</h3>

<p>
            サーバーやデータベース, 設定ファイル, その他のサーバーの運用に関わるコンポーネントの完全性を保護するために, 標準的なウェブサーバーの保護と設定方法を使うこと.
          
</p>
<a name="secure_storage"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.3"></a><h3>5.3.3.&nbsp;
Store Secrets in Secure Storage</h3>

<p>
            あらゆる種類のシークレット (トークン, クライアントシークレット) を安全にデバイスやサーバーに格納する方法は複数存在する.
          
</p>
<p>
            ほとんどのマルチユーザーオペレーティングシステムは個々のシステムユーザーの個人ストレージをそれぞれ分離して管理している.
            さらに, 最近のスマートフォンのオペレーティングシステムのほとんどはファイルシステムの分離された領域にアプリケーション固有のストレージまでも用意され, 他のアプリケーションからアクセスできないようになっている.
            加えて, アプリケーションはPINやパスワードといったユーザーが提供するシークレットを用いてデータの秘匿性を実現することもできる.
          
</p>
<p>
            別の方法としてリフレッシュトークンを信頼できるバックエンドサーバーに保管する方法が挙げられる.
            この方法ではクライアントとバックエンドサーバー間の強固な認証機構が必要となる.
            注: アプリケーションは, 秘匿データがセキュアストレージから読み出された後でも秘匿性を保持したままであることを保証すべきである.
            これは典型的にはこのデータをアプリケーションのローカルメモリ内で保持することを意味する.
          
</p>
<a name="device_lock"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.4"></a><h3>5.3.4.&nbsp;
Utilize Device Lock to Prevent Unauthorized Device Access</h3>

<p>
            典型的な最近の電話機では, デバイスを盗難された場合や置き忘れた場合に有用な追加の保護機構を持っている.
            これらはPINやパスワード, 顔認識のようなその他の生体情報を利用する.
            これらが提供するセキュリティレベルはそれぞれ同等ではない.
          
</p>
<a name="link_state_uasession"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.5"></a><h3>5.3.5.&nbsp;
Link the &quot;state&quot; Parameter to User Agent Session</h3>

<p>
            "state" パラメーターはクライアントに対する複数のリクエスト間を紐づけたり, リダイレクトURIなどに対するCSRF攻撃を防止するために使用される.
            攻撃者は彼ら自身の認可コードやアクセストークンをインジェクションすることが考えられ, その結果, 被害者のではなく攻撃者の保護リソースに関連づけられたアクセストークンをクライアントに使わせることになる (例えば, 被害者の銀行口座情報を攻撃者の制御下にある保護リソースに保存).
          
</p>
<p>
            クライアントは認可リクエストを作成する際, ユーザーエージェントの認証状態をリクエストに紐づけた値  (例えばユーザーエージェントの認証に用いたセッションクッキーのハッシュ) を認可サーバーに送るために "state" リクエストパラメーターを利用すべきである.
            エンドユーザーの認可が得られた後, 認可サーバーはリクエストに含まれているものと同じ値を持つ "state" パラメーターを付与し, エンドユーザーのユーザーエージェントをクライアントにリダイレクトバックさせる.
          
</p>
<p>
            この紐づけられた値とユーザーエージェントの認証状態のマッチングを行うことにより, クライアントはリクエストの妥当性を検証することができる.
          
</p>
<a name="anchor73"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4"></a><h3>5.4.&nbsp;
Resource Servers</h3>

<p>The following section details security considerations for resource
        servers.
</p>
<a name="authz_header"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.1"></a><h3>5.4.1.&nbsp;
Authorization Headers</h3>

<p>Authorization headers are recognized and specially treated by
          HTTP proxies and servers. Thus, the usage of such headers for sending
          access tokens to resource servers reduces the likelihood of leakage
          or unintended storage of authenticated requests in general, and
          especially Authorization headers.
</p>
<a name="authn_requests"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.2"></a><h3>5.4.2.&nbsp;
Authenticated Requests</h3>

<p>An authorization server may bind tokens to a certain client
          identifier and enable resource servers to validate that
          association on resource access. This will require the resource
          server to authenticate the originator of a request as the legitimate
          owner of a particular token. There are several options to
          implement this countermeasure:
</p>
<p></p>
<ul class="text">
<li>The authorization server may associate the client identifier
              with the token (either internally or in the payload of a
              self-contained token). The client then uses client
              certificate-based HTTP authentication on the resource server's
              endpoint to authenticate its identity, and the resource server
              validates the name with the name referenced by the token.
</li>
<li>Same as the option above, but the client uses his
              private key to sign
              the request to the resource server (the public key is either
              contained in the token or sent along with the request).
</li>
<li>Alternatively, the authorization server may issue a
              token-bound key, which the client uses in a
              Holder-of-Key proof to authenticate the client's use of the
              token. The resource server obtains the secret directly from
              the authorization server, or the secret is contained in an
              encrypted section of the token. In that way, the resource
              server does not "know" the client but is
              able to validate whether the authorization server issued the
              token to that client.
</li>
</ul><p>Authenticated requests are a countermeasure against abuse
          of tokens by counterfeit resource servers.
</p>
<a name="signed_requests"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.3"></a><h3>5.4.3.&nbsp;
Signed Requests</h3>

<p>A resource server may decide to accept signed requests only,
          either to replace transport-level security measures or to complement
          such measures. Every signed request should be uniquely identifiable
          and should not be processed twice by the resource server. This
          countermeasure helps to mitigate:
</p>
<p></p>
<ul class="text">
<li>modifications of the message and
</li>
<li>replay attempts
</li>
</ul>

<a name="installed_apps"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5"></a><h3>5.5.&nbsp;
A Word on User Interaction and User-Installed Apps</h3>

<p>OAuth, as a security protocol, is distinctive in that its flow
        usually involves significant user interaction, making the end user a
        part of the security model. This creates some important difficulties
        in defending against some of the threats discussed above. Some of
        these points have already been made, but it's worth repeating and
        highlighting them here.
</p>
<p></p>
<ul class="text">
<li>End users must understand what they are being asked to approve
            (see <a class='info' href='#informed_decisions'>Section&nbsp;5.2.4.2<span> (</span><span class='info'>Informed Decisions Based on Transparency</span><span>)</span></a>). Users
            often do not have the expertise to understand the ramifications of
            saying "yes" to an authorization request and are likely not to be
            able to see subtle differences in the wording of requests.
            Malicious software can confuse the user, tricking the user into
            approving almost anything.
</li>
<li>End-user devices are prone to software compromise. This has
            been a long-standing problem, with frequent attacks on web
            browsers and other parts of the user's system. But with the
            increasing popularity of user-installed "apps", the threat
            posed by compromised or malicious end-user software is very strong
            and is one that is very difficult to mitigate.
</li>
<li>Be aware that users will demand to install and run such apps,
            and that compromised or malicious ones can steal credentials at
            many points in the data flow. They can intercept the very user
            login credentials that OAuth is designed to protect. They can
            request authorization far beyond what they have led the user to
            understand and approve. They can automate a response on behalf of
            the user, hiding the whole process. No solution is offered here,
            because none is known; this remains in the space between better
            security and better usability.
</li>
<li>Addressing these issues by restricting the use of
            user-installed software may be practical in some limited
            environments and can be used as a countermeasure in those cases.
            Such restrictions are not practical in the general case, and
            mechanisms for after-the-fact recovery should be in place.
</li>
<li>While end users are mostly incapable of properly vetting
            applications they load onto their devices, those who deploy
            authorization servers might have tools at their disposal to
            mitigate malicious clients. For example, a well-run authorization
            server must only assert client properties to the end user it is
            effectively capable of validating, explicitly point out which
            properties it cannot validate, and indicate to the end user the
            risk associated with granting access to the particular client.
</li>
</ul>

<a name="Acknowledgements"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Acknowledgements</h3>

<p>We would like to thank Stephen Farrell, Barry Leiba, Hui-Lan Lu,
      Francisco Corella, Peifung E. Lam, Shane B. Weeden, Skylar Woodward, Niv
      Steingarten, Tim Bray, and James H. Manger for their comments and
      contributions.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>7.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC6749">[RFC6749]</a></td>
<td class="author-text">Hardt, D., &ldquo;<a href="http://tools.ietf.org/html/rfc6749">The OAuth 2.0 Authorization Framework</a>,&rdquo; RFC&nbsp;6749, October&nbsp;2012 (<a href="http://www.rfc-editor.org/rfc/rfc6749.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC6750">[RFC6750]</a></td>
<td class="author-text">Jones, M. and D. Hardt, &ldquo;<a href="http://tools.ietf.org/html/rfc6750">The OAuth 2.0 Authorization Framework: Bearer Token Usage</a>,&rdquo; RFC&nbsp;6750, October&nbsp;2012 (<a href="http://www.rfc-editor.org/rfc/rfc6750.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>7.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="Framebusting">[Framebusting]</a></td>
<td class="author-text">Rydstedt, G., Bursztein, Boneh, D., and C. Jackson, &ldquo;<a href="http://elie.im/publication/busting-frame-busting-a-study-of-clickjacking-vulnerabilities-on-popular-sites">Busting Frame Busting: a Study of Clickjacking
          Vulnerabilities on Popular Sites</a>,&rdquo; IEEE&nbsp;3rd Web 2.0 Security and Privacy Workshop, May&nbsp;2010.</td></tr>
<tr><td class="author-text" valign="top"><a name="IMEI">[IMEI]</a></td>
<td class="author-text">3GPP, &ldquo;<a href="http://www.3gpp.org/ftp/Specs/html-info/22016.htm">International Mobile station Equipment Identities
          (IMEI)</a>,&rdquo; 3GPP TS&nbsp;22.016 11.0.0, September&nbsp;2012.</td></tr>
<tr><td class="author-text" valign="top"><a name="OASIS.saml-core-2.0-os">[OASIS.saml-core-2.0-os]</a></td>
<td class="author-text">Cantor, S., Ed., Kemp, J., Ed., Philpott, R., Ed., and E. Maler, Ed., &ldquo;<a href="http://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf">Assertions and Protocols for the OASIS Security Assertion Markup
Language (SAML) V2.0</a>,&rdquo; OASIS Standard&nbsp;saml-core-2.0-os, March&nbsp;2005.</td></tr>
<tr><td class="author-text" valign="top"><a name="OASIS.sstc-saml-bindings-1.1">[OASIS.sstc-saml-bindings-1.1]</a></td>
<td class="author-text">Maler, E., Ed., Mishra, P., Ed., and R. Philpott, Ed., &ldquo;<a href="http://www.oasis-open.org/committees/download.php/3405/oasis-sstc-saml-bindings-1.1.pdf">Bindings and Profiles for the OASIS Security Assertion Markup
          Language (SAML) V1.1</a>,&rdquo; September&nbsp;2003.</td></tr>
<tr><td class="author-text" valign="top"><a name="OASIS.sstc-sec-analysis-response-01">[OASIS.sstc-sec-analysis-response-01]</a></td>
<td class="author-text">Linn, J., Ed. and P. Mishra, Ed., &ldquo;<a href="http://www.oasis-open.org/committees/download.php/11191/sstc-gross-sec-analysis-response-01.pdf">SSTC Response to &ldquo;Security Analysis of the SAML Single
          Sign-on Browser/Artifact Profile&rdquo;</a>,&rdquo; January&nbsp;2005.</td></tr>
<tr><td class="author-text" valign="top"><a name="OAuth-ASSERTIONS">[OAuth-ASSERTIONS]</a></td>
<td class="author-text">Campbell, B., Mortimore, C., Jones, M., and Y. Goland, &ldquo;Assertion Framework for OAuth 2.0,&rdquo; Work in&nbsp;Progress, December&nbsp;2012.</td></tr>
<tr><td class="author-text" valign="top"><a name="OAuth-HTTP-MAC">[OAuth-HTTP-MAC]</a></td>
<td class="author-text">Richer, J., Ed., Mills, W., Ed., and H. Tschofenig, Ed., &ldquo;OAuth 2.0 Message Authentication Code (MAC) Tokens,&rdquo; Work in&nbsp;Progress, November&nbsp;2012.</td></tr>
<tr><td class="author-text" valign="top"><a name="OAuth-JWT">[OAuth-JWT]</a></td>
<td class="author-text">Jones, M., Bradley, J., and N. Sakimura, &ldquo;JSON Web Token (JWT),&rdquo; Work in&nbsp;Progress, December&nbsp;2012.</td></tr>
<tr><td class="author-text" valign="top"><a name="OAuth-REVOCATION">[OAuth-REVOCATION]</a></td>
<td class="author-text">Lodderstedt, T., Ed., Dronia, S., and M. Scurtescu, &ldquo;Token Revocation,&rdquo; Work in&nbsp;Progress, November&nbsp;2012.</td></tr>
<tr><td class="author-text" valign="top"><a name="OPENID">[OPENID]</a></td>
<td class="author-text">&ldquo;<a href="http://openid.net/">OpenID Foundation Home Page</a>.&rdquo;</td></tr>
<tr><td class="author-text" valign="top"><a name="OWASP">[OWASP]</a></td>
<td class="author-text">&ldquo;<a href="https://www.owasp.org/">Open Web Application Security Project Home Page</a>.&rdquo;</td></tr>
<tr><td class="author-text" valign="top"><a name="Portable-Contacts">[Portable-Contacts]</a></td>
<td class="author-text">Smarr, J., &ldquo;<a href="http://portablecontacts.net/">Portable Contacts 1.0 Draft C</a>,&rdquo; August&nbsp;2008.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2616">[RFC2616]</a></td>
<td class="author-text"><a href="mailto:fielding@ics.uci.edu">Fielding, R.</a>, <a href="mailto:jg@w3.org">Gettys, J.</a>, <a href="mailto:mogul@wrl.dec.com">Mogul, J.</a>, <a href="mailto:frystyk@w3.org">Frystyk, H.</a>, <a href="mailto:masinter@parc.xerox.com">Masinter, L.</a>, <a href="mailto:paulle@microsoft.com">Leach, P.</a>, and <a href="mailto:timbl@w3.org">T. Berners-Lee</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2616">Hypertext Transfer Protocol -- HTTP/1.1</a>,&rdquo; RFC&nbsp;2616, June&nbsp;1999 (<a href="http://www.rfc-editor.org/rfc/rfc2616.txt">TXT</a>, <a href="http://www.rfc-editor.org/rfc/rfc2616.ps">PS</a>, <a href="http://www.rfc-editor.org/rfc/rfc2616.pdf">PDF</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2616.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2616.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2818">[RFC2818]</a></td>
<td class="author-text">Rescorla, E., &ldquo;<a href="http://tools.ietf.org/html/rfc2818">HTTP Over TLS</a>,&rdquo; RFC&nbsp;2818, May&nbsp;2000 (<a href="http://www.rfc-editor.org/rfc/rfc2818.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4086">[RFC4086]</a></td>
<td class="author-text">Eastlake, D., Schiller, J., and S. Crocker, &ldquo;<a href="http://tools.ietf.org/html/rfc4086">Randomness Requirements for Security</a>,&rdquo; BCP&nbsp;106, RFC&nbsp;4086, June&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4086.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4120">[RFC4120]</a></td>
<td class="author-text">Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;<a href="http://tools.ietf.org/html/rfc4120">The Kerberos Network Authentication Service (V5)</a>,&rdquo; RFC&nbsp;4120, July&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4120.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4301">[RFC4301]</a></td>
<td class="author-text">Kent, S. and K. Seo, &ldquo;<a href="http://tools.ietf.org/html/rfc4301">Security Architecture for the Internet Protocol</a>,&rdquo; RFC&nbsp;4301, December&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4301.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5246">[RFC5246]</a></td>
<td class="author-text">Dierks, T. and E. Rescorla, &ldquo;<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>,&rdquo; RFC&nbsp;5246, August&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5246.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="SSL-Latency">[SSL-Latency]</a></td>
<td class="author-text">Sissel, J., Ed., &ldquo;SSL handshake latency and HTTPS optimizations,&rdquo; June&nbsp;2010.</td></tr>
<tr><td class="author-text" valign="top"><a name="Sec-Analysis">[Sec-Analysis]</a></td>
<td class="author-text">Gro&szlig;, T., &ldquo;Security Analysis of the SAML Single Sign-on Browser/Artifact
          Profile,&rdquo; 19th Annual Computer Security Applications Conference,&nbsp;Las Vegas, December&nbsp;2003.</td></tr>
<tr><td class="author-text" valign="top"><a name="X-Frame-Options">[X-Frame-Options]</a></td>
<td class="author-text">Ross, D. and T. Gondrom, &ldquo;HTTP Header X-Frame-Options,&rdquo; Work in&nbsp;Progress, October&nbsp;2012.</td></tr>
<tr><td class="author-text" valign="top"><a name="iFrame">[iFrame]</a></td>
<td class="author-text">World Wide Web Consortium, &ldquo;<a href="http://www.w3.org/TR/html4/present/frames.html#h-16.5">Frames in HTML documents</a>,&rdquo; W3C&nbsp;HTML 4.01, December&nbsp;1999.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Torsten Lodderstedt (editor)</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Deutsche Telekom AG</td></tr>
<tr><td class="author" align="right">EMail:&nbsp;</td>
<td class="author-text"><a href="mailto:torsten@lodderstedt.net">torsten@lodderstedt.net</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Mark McGloin</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">IBM</td></tr>
<tr><td class="author" align="right">EMail:&nbsp;</td>
<td class="author-text"><a href="mailto:mark.mcgloin@ie.ibm.com">mark.mcgloin@ie.ibm.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Phil Hunt</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Oracle Corporation</td></tr>
<tr><td class="author" align="right">EMail:&nbsp;</td>
<td class="author-text"><a href="mailto:phil.hunt@yahoo.com">phil.hunt@yahoo.com</a></td></tr>
</table>
</body></html>
